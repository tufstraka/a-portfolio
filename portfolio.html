
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keith Kadima (Digital FootPrint)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #D0E7FF;
            overflow: hidden;
            cursor: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #005544;
            background: rgba(255, 255, 255, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0, 119, 85, 0.3);
            box-shadow: 0 8px 32px rgba(0, 119, 85, 0.1);
            animation: pulse-glow 3s infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% {box-shadow: 0 8px 32px rgba(0, 119, 85, 0.1);}
            50% {box-shadow: 0 8px 32px rgba(0, 119, 85, 0.3);}
        }
        
        #instructions {
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
            text-shadow: 0 0 5px rgba(0, 119, 85, 0.3);
        }
        
        #speed {
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 119, 85, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        #modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(230, 245, 255, 0.95) 100%);
            color: #222;
            padding: 40px;
            border-radius: 20px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 200;
            display: none;
            backdrop-filter: blur(25px);
            border: 3px solid #007755;
            box-shadow: 0 20px 60px rgba(0, 119, 85, 0.3), inset 0 0 30px rgba(0, 119, 85, 0.1);
            animation: modalAppear 0.3s ease-out;
        }
        
        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        #modal h2 {
            color: #006644;
            margin-bottom: 20px;
            text-align: center;
            font-size: 28px;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(0, 119, 85, 0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #modal p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
        
        #closeModal {
            background: linear-gradient(45deg, #007755, #005544);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            display: block;
            margin: 30px auto 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 119, 85, 0.4);
        }
        
        #closeModal:hover {
            background: linear-gradient(45deg, #006644, #004433);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 119, 85, 0.6);
        }
        
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            height: 220px;
            background: rgba(255, 255, 255, 0.7);
            border: 3px solid #007755;
            border-radius: 15px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 119, 85, 0.2);
        }
        
        .section-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.85), rgba(220, 245, 240, 0.9));
            color: #006644;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            display: none;
            z-index: 100;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 2px solid #007755;
            box-shadow: 0 10px 30px rgba(0, 119, 85, 0.4);
            animation: pulse-border 2s infinite;
        }
        
        @keyframes pulse-border {
            0%, 100% { border-color: rgba(0, 119, 85, 0.8); }
            50% { border-color: rgba(0, 119, 85, 0.3); }
        }
        
        #customCursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #007755, transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease;
            box-shadow: 0 0 15px #007755;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #007755;
            font-size: 24px;
            font-weight: 700;
            z-index: 1000;
            text-shadow: 0 0 20px rgba(0, 119, 85, 0.8);
        }
        
        #loadingBar {
            position: absolute;
            top: 58%;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 4px;
            background: rgba(0, 119, 85, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        #loadingBarFill {
            height: 100%;
            width: 0%;
            background: #007755;
            box-shadow: 0 0 10px #007755;
            transition: width 0.5s ease;
        }
        
        .fps-counter {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #007755;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 10px;
        }

        #settingsMenu {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            color: #006644;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            border: 2px solid rgba(0, 119, 85, 0.3);
            display: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        #settingsMenu h3 {
            margin-bottom: 10px;
            text-align: center;
        }

        #settingsMenu label {
            display: block;
            margin: 8px 0;
        }

        #settingsMenu select {
            background: #e8f8f0;
            color: #006644;
            border: 1px solid #007755;
            padding: 5px;
            width: 100%;
        }

        #settingsMenu button {
            background: #007755;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
            width: 100%;
        }

        #settingsBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            color: #006644;
            border: 1px solid #007755;
            border-radius: 5px;
            padding: 5px 10px;
            z-index: 101;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="customCursor"></div>
    <div id="gameContainer">
        <div class="loading" id="loading">INITIALIZING KADIMA'S DIGITAL FOOTPRINT</div>
        <div id="loadingBar"><div id="loadingBarFill"></div></div>
        
        <div id="ui">
            <div id="instructions">
                üöó <strong>WASD/Arrow Keys:</strong> Drive<br>
                üéØ <strong>Drive near buildings</strong> to explore<br>
                üöÄ <strong>SPACE:</strong> Enter section<br>
                ‚ö° <strong>SHIFT:</strong> Boost<br>
                üö∂ <strong>E:</strong> Enter/Exit Vehicle<br>
                üì∑ <strong>C:</strong> Change Camera<br>
                üîç <strong>MOUSE WHEEL:</strong> Zoom
            </div>
            <div id="speed">Speed: 0 km/h</div>
        </div>
        
        <div id="modal">
            <h2 id="modalTitle"></h2>
            <div id="modalContent"></div>
            <button id="closeModal">Close Interface</button>
        </div>
        
        <div class="section-indicator" id="sectionIndicator"></div>
        
        <canvas id="minimap"></canvas>
        <div class="fps-counter" id="fpsCounter">FPS: 60</div>

        <button id="settingsBtn">‚öôÔ∏è Settings</button>
        <div id="settingsMenu">
            <h3>VISUAL SETTINGS</h3>
            <label>Quality:
                <select id="qualitySelect">
                    <option value="low">Low</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High</option>
                </select>
            </label>
            <label>Effects:
                <select id="effectsSelect">
                    <option value="minimal">Minimal</option>
                    <option value="balanced" selected>Balanced</option>
                    <option value="ultra">Ultra</option>
                </select>
            </label>
            <button id="applySettings">Apply</button>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // Enhanced portfolio data with cyberpunk descriptions
        const portfolioData = {
            'About Me': {
                content: `<strong>üöÄ IDENTITY: DIGITAL ARCHITECT</strong><br><br>
                Neural-integrated developer operating at the intersection of code and creativity within the digital realm.<br><br>
                
                <strong>CORE PROTOCOLS:</strong><br>
                ‚Ä¢ Neural-interface experience design for maximum user immersion<br>
                ‚Ä¢ Quantum-accelerated code optimization<br>
                ‚Ä¢ Wetware-compatible digital solutions<br>
                ‚Ä¢ Continuous neural-uplink learning streams<br><br>
                
                When disconnected from the mainframe, I explore innovative AI concepts, contribute to open-source projects, and optimize my personal development algorithms.<br><br>
                
                <em>// Welcome to my neural portfolio projection - explore my digital footprint in daylight //</em>`,
                position: { x: 0, z: 0 },
                color: 0x007755
            },
            'Neural Augments': {
                content: `<strong>üéì COGNITIVE UPGRADES</strong><br><br>
                
                <strong>NEURAL SUBNET: Advanced Computation</strong><br>
                Neo-Tokyo Institute of Technology (2076-2078)<br>
                <em>Specialization: Quantum Neural Interfaces & Holographic Rendering</em><br><br>
                
                <strong>SUBNET: Software Architecture</strong><br>
                Techno-Organic University (2072-2076)<br>
                <em>Graduated with Neural Distinction</em><br><br>
                
                <strong>üèÜ ACHIEVEMENT METRICS:</strong><br>
                ‚Ä¢ Grid Master - 6 consecutive network cycles<br>
                ‚Ä¢ Singularity Award for Neural Engine Development<br>
                ‚Ä¢ CyberCode Championship - 2nd Node<br>
                ‚Ä¢ Published research on Quantum Holographic Interfaces<br><br>
                
                <strong>üìö RELEVANT NEURAL IMPRINTS:</strong><br>
                Quantum Algorithm Design, Holographic Computation, Neural-Machine Integration, Wetware Programming, Digital Consciousness Architecture, Human-AI Symbiosis`,
                position: { x: -60, z: -40 },
                color: 0x3355AA
            },
            'Tech Implants': {
                content: `<strong>üíª INTEGRATED TECH STACK</strong><br><br>
                
                <strong>CORE PROTOCOLS:</strong><br>
                ‚Ä¢ NeuroScript/TypeSynapse (Neural-Level)<br>
                ‚Ä¢ Quantum Python (Advanced)<br>
                ‚Ä¢ ReactVR/HoloNext.js (Neural-Level)<br>
                ‚Ä¢ NodeCore/Synaptic Express (Advanced)<br>
                ‚Ä¢ HoloThree.js/NeuroGL (Neural-Level)<br>
                ‚Ä¢ C++/BioGL (Intermediate)<br><br>
                
                <strong>üé® SENSORY AUGMENTATIONS:</strong><br>
                ‚Ä¢ 4D Sensory Modeling & Neural Animation<br>
                ‚Ä¢ Synesthetic Shader Programming<br>
                ‚Ä¢ Neuro-Response UI/UX Design<br>
                ‚Ä¢ Thought-Motion Synthesis<br><br>
                
                <strong>‚òÅÔ∏è NETWORK INTEGRATION:</strong><br>
                ‚Ä¢ Quantum Cloud Architecture (Certified)<br>
                ‚Ä¢ Neural Container Management<br>
                ‚Ä¢ Thought-Sync Deployment Pipelines<br>
                ‚Ä¢ Distributed Consciousness Architecture<br><br>
                
                <strong>üß† AI SYMBIOSIS:</strong><br>
                ‚Ä¢ Neural Network/Human Integration<br>
                ‚Ä¢ Synthetic Vision Systems<br>
                ‚Ä¢ Natural Language Matrix<br>
                ‚Ä¢ Data Consciousness Visualization`,
                position: { x: 60, z: -40 },
                color: 0xBB4422
            },
            'Digital Artifacts': {
                content: `<strong>üöÄ MANIFESTED CONSTRUCTS</strong><br><br>
                
                <strong>1. NeuroVerse - Bio-Digital Reality Matrix</strong><br>
                Neural-generated immersive universe with synthetic consciousness interactions<br>
                <em>Tech: Neural Three.js, TensorCore.js, Quantum Shaders</em><br><br>
                
                <strong>2. HoloCommerce Platform</strong><br>
                Full-sensory commercial experience with neural-haptic feedback<br>
                <em>Tech: NeuroReact, Synapse.js, Quantum Cloud</em><br><br>
                
                <strong>3. MindSage - Thought Optimization Engine</strong><br>
                AI-symbiotic code analysis and neural enhancement system<br>
                <em>Tech: Quantum Python, OpenMind API, Neural Core</em><br><br>
                
                <strong>4. CyberDrive</strong><br>
                This immersive neural-interface driving experience you're jacked into<br>
                <em>Tech: Three.js, Neural WebGL, Advanced BioCyber Shaders</em><br><br>
                
                <strong>5. NeuraMesh</strong><br>
                Decentralized thought-sync platform for distributed consciousness<br>
                <em>Tech: Neural WebRTC, Synapse.io, Quantum Cloud, Thought Containers</em>`,
                position: { x: 0, z: -80 },
                color: 0x992266
            },
            'Neural Timeline': {
                content: `<strong>üíº CORPORATE INTEGRATION HISTORY</strong><br><br>
                
                <strong>Senior Neural Engineer</strong><br>
                CyberCore Industries (2079-Present)<br>
                ‚Ä¢ Architected next-gen neural interfaces with 300% efficiency increase<br>
                ‚Ä¢ Implemented thought-based system architecture used by 1.5M+ users<br>
                ‚Ä¢ Mentored junior engineers in neural integration techniques<br>
                ‚Ä¢ Designed microsynaptic services handling 10M+ thought-requests daily<br><br>
                
                <strong>Holographic Developer</strong><br>
                Digital Dreamscape Collective (2077-2079)<br>
                ‚Ä¢ Created immersive neural-WebGL experiences<br>
                ‚Ä¢ Developed proprietary thought-rendering components<br>
                ‚Ä¢ Optimized neural-interfaces for biological compatibility<br>
                ‚Ä¢ Collaborated with neuro-designers on award-winning projections<br><br>
                
                <strong>Code Jockey Intern</strong><br>
                NeuroCorp (Summer 2076)<br>
                ‚Ä¢ Enhanced neural-chrome WebGL integration<br>
                ‚Ä¢ Implemented thought-based performance optimizations<br>
                ‚Ä¢ Contributed to internal neural-sync tools<br><br>
                
                <strong>Independent NetRunner</strong><br>
                The Free Grid (2075-Present)<br>
                ‚Ä¢ 50+ neural imprint projects successfully deployed<br>
                ‚Ä¢ Specialized in synaptic interface design<br>
                ‚Ä¢ Maintained 98% bio-compatibility rating`,
                position: { x: -60, z: 40 },
                color: 0x227744
            },
            'Neural Link': {
                content: `<strong>üì° ESTABLISH CONNECTION</strong><br><br>
                
                Ready to initiate a neural handshake for potential collaboration? My connection ports are always open for interesting data packets.<br><br>
                
                <strong>üìß Neural-Mail:</strong> netrunner@cyberportfolio.net<br>
                <strong>üíº Neural-Link:</strong> neuralink.com/in/netrunner<br>
                <strong>üêô CodeRepository:</strong> gitbrain.com/netrunner<br>
                <strong>üåê Neural-Projection:</strong> www.cyberportfolio.net<br>
                <strong>üì± Direct Uplink:</strong> +1 (555) NET-RUN<br><br>
                
                <strong>üè† Physical Terminal:</strong> Neo-San Francisco, Bay City<br>
                <strong>üåç Remote Connection:</strong> Available across all timezones<br><br>
                
                <strong>üí° Current Interest Vectors:</strong><br>
                ‚Ä¢ Decentralized neural networks<br>
                ‚Ä¢ Synthetic consciousness interfaces<br>
                ‚Ä¢ Immersive holographic experiences<br>
                ‚Ä¢ Open-source neural augmentations<br><br>
                
                <em>// Initiate handshake protocol to begin data exchange //</em>`,
                position: { x: 60, z: 40 },
                color: 0x665599
            }
        };

        // ------------------ INITIALIZATION & GLOBAL VARIABLES ------------------
        
        // Device & Capability Detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEndDevice = () => {
            if (navigator.deviceMemory && navigator.deviceMemory < 4) return true;
            if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) return true;
            return false;
        };
        
        // Performance Settings
        let qualitySettings = {
            effectsLevel: isMobile ? 'minimal' : isLowEndDevice() ? 'balanced' : 'ultra',
            quality: isMobile ? 'low' : isLowEndDevice() ? 'medium' : 'high',
            particleCount: isMobile ? 500 : isLowEndDevice() ? 2000 : 5000,
            shadowsEnabled: !isMobile && !isLowEndDevice(),
            maxLights: isMobile ? 5 : isLowEndDevice() ? 15 : 30,
            drawDistance: isMobile ? 200 : isLowEndDevice() ? 500 : 1500,
            instancedMeshes: !isMobile,
            postProcessing: isMobile ? 'minimal' : isLowEndDevice() ? 'balanced' : 'full',
            textureSize: isMobile ? 'small' : isLowEndDevice() ? 'medium' : 'large',
            LODEnabled: true,
            geometryDetail: isMobile ? 'low' : isLowEndDevice() ? 'medium' : 'high'
        };
        
        // Core Three.js Components
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let car, character;
        
        // Game State Variables
        let playerMode = 'driving'; // 'driving' or 'walking'
        let cameraMode = 'follow'; // 'follow', 'orbit', 'first-person'
        let cameraAngle = 0;
        let cameraDistance = 15, cameraHeight = 10;
        let carSpeed = 0, maxSpeed = 2.5, acceleration = 0.12, friction = 0.06;
        let currentSection = null;
        let keys = {};
        
        // Scene Object Collections
        let sections = [], buildings = [], billboards = [], drones = [];
        let hologramProjections = [], neonSigns = [], powerLines = [];
        let instancedObjects = {};
        
        // Visual Effects
        let bloomPass, glitchPass;
        let customCursor;
        let cityLights = [];
        let particleSystems = [];
        
        // Sky and environment
        let sky, sun;
        
        // Performance Monitoring
        let lastTime = 0, fps = 0, frameCount = 0;
        let updateCounter = 0;
        
        // Resource Management
        const textureLoader = new THREE.TextureLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);
        
        // Asset Caches
        const textureCache = {};
        const materialCache = {};
        const geometryCache = {};
        const shaderCache = {};
        
        // ------------------ OPTIMIZED RESOURCE MANAGEMENT ------------------
        
        // Texture loading with cache
        function loadTexture(url) {
            if (!textureCache[url]) {
                textureCache[url] = textureLoader.load(url);
                
                // Apply common settings to textures
                textureCache[url].anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;
                
                // Size adjustments based on quality settings
                if (qualitySettings.textureSize === 'small') {
                    textureCache[url].minFilter = THREE.LinearFilter;
                    textureCache[url].magFilter = THREE.LinearFilter;
                }
            }
            return textureCache[url];
        }
        
        // Material creation with cache
        function createMaterial(type, params, cacheKey) {
            // Generate cache key if not provided
            if (!cacheKey && params.color) {
                cacheKey = `${type}-${params.color}-${params.metalness || 0}-${params.roughness || 0}`;
            }
            
            if (cacheKey && materialCache[cacheKey]) {
                return materialCache[cacheKey];
            }
            
            let material;
            
            switch(type) {
                case 'standard':
                    material = new THREE.MeshStandardMaterial(params);
                    break;
                case 'physical':
                    material = new THREE.MeshPhysicalMaterial(params);
                    break;
                case 'basic':
                    material = new THREE.MeshBasicMaterial(params);
                    break;
                case 'shader':
                    material = new THREE.ShaderMaterial(params);
                    break;
                default:
                    material = new THREE.MeshStandardMaterial(params);
            }
            
            if (cacheKey) {
                materialCache[cacheKey] = material;
            }
            
            return material;
        }
        
        // Get geometry with LOD support
        function getGeometry(type, params, detail = 'medium') {
            // Set resolution multipliers based on detail level
            const detailLevels = {
                'low': 0.5,
                'medium': 1,
                'high': 1.5
            };
            
            const detailMultiplier = detailLevels[detail] || 1;
            const cacheKey = `${type}-${JSON.stringify(params)}-${detail}`;
            
            if (geometryCache[cacheKey]) {
                return geometryCache[cacheKey];
            }
            
            let geometry;
            
            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(
                        params.width, 
                        params.height, 
                        params.depth, 
                        Math.max(1, Math.floor(params.widthSegments * detailMultiplier)) || 1,
                        Math.max(1, Math.floor(params.heightSegments * detailMultiplier)) || 1,
                        Math.max(1, Math.floor(params.depthSegments * detailMultiplier)) || 1
                    );
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(
                        params.radius,
                        Math.max(8, Math.floor(24 * detailMultiplier)),
                        Math.max(6, Math.floor(16 * detailMultiplier))
                    );
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(
                        params.radiusTop,
                        params.radiusBottom,
                        params.height,
                        Math.max(8, Math.floor(24 * detailMultiplier)),
                        Math.max(1, Math.floor(params.heightSegments * detailMultiplier)) || 1,
                        params.openEnded || false
                    );
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(
                        params.width,
                        params.height,
                        Math.max(1, Math.floor(params.widthSegments * detailMultiplier)) || 1,
                        Math.max(1, Math.floor(params.heightSegments * detailMultiplier)) || 1
                    );
                    break;
                case 'circle':
                    geometry = new THREE.CircleGeometry(
                        params.radius,
                        Math.max(8, Math.floor(32 * detailMultiplier))
                    );
                    break;
                case 'ring':
                    geometry = new THREE.RingGeometry(
                        params.innerRadius,
                        params.outerRadius,
                        Math.max(8, Math.floor(32 * detailMultiplier))
                    );
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(
                        params.radius,
                        params.height,
                        Math.max(8, Math.floor(32 * detailMultiplier)),
                        Math.max(1, Math.floor(params.heightSegments * detailMultiplier)) || 1,
                        params.openEnded || false
                    );
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(
                        params.radius,
                        params.tube,
                        Math.max(8, Math.floor(16 * detailMultiplier)),
                        Math.max(6, Math.floor(params.tubularSegments * detailMultiplier))
                    );
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(
                        params.radius,
                        params.detail || 0
                    );
                    break;
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
            }
            
            geometryCache[cacheKey] = geometry;
            return geometry;
        }
        
        // Shader management with cache
        function createShaderMaterial(uniforms, vertexShader, fragmentShader, params = {}) {
            // Create a hash for caching
            const shaderHash = vertexShader.length + fragmentShader.length;
            
            if (shaderCache[shaderHash]) {
                // Clone uniforms to avoid reference issues
                const cachedMaterial = shaderCache[shaderHash].clone();
                cachedMaterial.uniforms = THREE.UniformsUtils.clone(uniforms);
                return cachedMaterial;
            }
            
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: params.transparent !== undefined ? params.transparent : false,
                blending: params.blending || THREE.NormalBlending,
                side: params.side || THREE.FrontSide,
                depthWrite: params.depthWrite !== undefined ? params.depthWrite : true
            });
            
            shaderCache[shaderHash] = material;
            
            return material;
        }
        
        // Clean up resources properly
        function disposeObject(obj) {
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => disposeMaterial(material));
                } else {
                    disposeMaterial(obj.material);
                }
            }
            
            if (obj.parent) {
                obj.parent.remove(obj);
            }
        }
        
        function disposeMaterial(material) {
            if (!material) return;
            
            // Dispose textures
            Object.keys(material).forEach(prop => {
                if (!material[prop]) return;
                if (material[prop].isTexture) {
                    material[prop].dispose();
                }
            });
            
            // Dispose uniforms if it's a shader material
            if (material.uniforms) {
                Object.keys(material.uniforms).forEach(prop => {
                    if (!material.uniforms[prop]) return;
                    if (material.uniforms[prop].value && material.uniforms[prop].value.isTexture) {
                        material.uniforms[prop].value.dispose();
                    }
                });
            }
            
            material.dispose();
        }
        
        // ------------------ MAIN INITIALIZATION ------------------
        
        function init() {
            initCustomCursor();
            setupEventListeners();
            
            // Create scene with optimized fog
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xE6F0FF, 0.0003); // Lighter fog, less dense
            
            // Setup camera with dynamic parameters
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, qualitySettings.drawDistance);
            
            // Setup renderer with optimized settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: qualitySettings.quality !== 'low',
                powerPreference: "high-performance",
                precision: qualitySettings.quality === 'low' ? "mediump" : "highp",
                stencil: false,
                depth: true
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, qualitySettings.quality === 'low' ? 1 : 2));
            renderer.shadowMap.enabled = qualitySettings.shadowsEnabled;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9; // Reduced from 1.2
            renderer.setClearColor(0xD0E7FF); // Slightly more natural sky color
            renderer.info.autoReset = false; // Manual tracking for better performance
            
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Load game assets progressively
            loadAssetsProgressively();
        }
        
        function loadAssetsProgressively() {
            const loadQueue = [
                // High priority assets (essential for gameplay)
                { fn: setupPostProcessing, priority: "high", weight: 10 },
                { fn: createDaylightEnvironment, priority: "high", weight: 20 },
                { fn: createRealisticGround, priority: "high", weight: 15 },
                { fn: createVehicles, priority: "high", weight: 15 },
                
                // Medium priority assets (important but can be delayed)
                { fn: createDaylightLighting, priority: "medium", weight: 10 },
                { fn: setupControls, priority: "medium", weight: 5 },
                { fn: createPortfolioSections, priority: "medium", weight: 15 },
                
                // Low priority assets (visual enhancements)
                { fn: createSkyAndClouds, priority: "low", weight: 5 },
                { fn: () => {
                    if (qualitySettings.effectsLevel !== 'minimal') {
                        createParticleEffects();
                    }
                }, priority: "low", weight: 10 },
                { fn: createBillboards, priority: "low", weight: 5 },
                { fn: createDrones, priority: "low", weight: 5 },
                { fn: () => {
                    if (qualitySettings.effectsLevel === 'ultra') {
                        createHolographicEffects();
                        createPowerGrid();
                        createCyberpunkDetails();
                    }
                }, priority: "low", weight: 10 },
                { fn: createEnvironmentalElements, priority: "low", weight: 10 }
            ];
            
            // Calculate total weight for progress bar
            const totalWeight = loadQueue.reduce((total, item) => total + item.weight, 0);
            let loadedWeight = 0;
            
            // Sort by priority
            loadQueue.sort((a, b) => {
                const priorities = { "high": 0, "medium": 1, "low": 2 };
                return priorities[a.priority] - priorities[b.priority];
            });
            
            // Load progressively
            function loadNextItem(index) {
                if (index >= loadQueue.length) {
                    // Everything is loaded, start the animation loop
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('loadingBar').style.display = 'none';
                    
                    // Trigger glitch effect when ready
                    if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                        glitchPass.enabled = true;
                        setTimeout(() => {
                            glitchPass.enabled = false;
                        }, 1500);
                    }
                    
                    animate();
                    return;
                }
                
                const item = loadQueue[index];
                
                try {
                    // Execute the loading function
                    item.fn();
                } catch (error) {
                    console.error(`Error loading item: ${error}`);
                }
                
                // Update progress
                loadedWeight += item.weight;
                const progress = loadedWeight / totalWeight;
                document.getElementById('loadingBarFill').style.width = `${progress * 100}%`;
                
                // Schedule next item with dynamic delay based on priority
                const delay = item.priority === "high" ? 0 : 
                             item.priority === "medium" ? 50 : 
                             100;
                
                setTimeout(() => loadNextItem(index + 1), delay);
            }
            
            // Start loading the first item
            loadNextItem(0);
        }
        
        // ------------------ SCENE CREATION FUNCTIONS ------------------
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            // Standard render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Optimization: Only add FXAA on medium/high quality
            if (qualitySettings.quality !== 'low') {
                const fxaaPass = new ShaderPass(FXAAShader);
                const pixelRatio = renderer.getPixelRatio();
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
                composer.addPass(fxaaPass);
            }
            
            // Bloom pass with reduced intensity for daylight
            let bloomStrength, bloomRadius, bloomThreshold;
            
            switch(qualitySettings.postProcessing) {
                case 'minimal':
                    bloomStrength = 0.15; // Reduced from 0.3
                    bloomRadius = 0.4;
                    bloomThreshold = 0.95; // Increased threshold
                    break;
                case 'balanced':
                    bloomStrength = 0.2; // Reduced from 0.4
                    bloomRadius = 0.35;
                    bloomThreshold = 0.9; // Increased threshold
                    break;
                case 'full':
                    bloomStrength = 0.25; // Reduced from 0.5
                    bloomRadius = 0.3;
                    bloomThreshold = 0.85; // Increased threshold
                    break;
            }
            
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                bloomStrength,
                bloomRadius,
                bloomThreshold
            );
            composer.addPass(bloomPass);
            
            // Only add glitch pass on high-end devices
            if (qualitySettings.effectsLevel === 'ultra') {
                glitchPass = new GlitchPass(0.5);
                glitchPass.enabled = false; // Only enable at specific moments
                composer.addPass(glitchPass);
            }
        }
        
        function createDaylightEnvironment() {
            // Create ground plane with realistic daylight materials
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = createMaterial('standard', {
                color: 0x88AA77, // Green-tinted ground for daylight
                roughness: 0.9,
                metalness: 0.1
            }, 'ground-daylight');
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = qualitySettings.shadowsEnabled;
            scene.add(ground);
            
            // Create road
            const roadGeometry = new THREE.PlaneGeometry(15, 1000);
            const roadMaterial = createMaterial('standard', {
                color: 0x555555, // Asphalt color
                roughness: 0.8,
                metalness: 0.2
            }, 'road-daylight');
            
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01;
            road.receiveShadow = qualitySettings.shadowsEnabled;
            scene.add(road);
            
            // Base ambient light with balanced values
            const ambientLight = new THREE.AmbientLight(0xCCDDFF, 0.5); // Reduced intensity
            scene.add(ambientLight);
            
            // Main directional light for sun - warmer and more natural
            const mainLight = new THREE.DirectionalLight(0xFFFAF0, 1.0); // Softer sunlight
            mainLight.position.set(50, 100, 50);
            
            if (qualitySettings.shadowsEnabled) {
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 1;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -200;
                mainLight.shadow.camera.right = 200;
                mainLight.shadow.camera.top = 200;
                mainLight.shadow.camera.bottom = -200;
                mainLight.shadow.bias = -0.0003;
            }
            scene.add(mainLight);

            // Add subtle hemisphere light
            const hemiLight = new THREE.HemisphereLight(0x90B0E0, 0x8AAA66, 0.4); // Reduced intensity
            scene.add(hemiLight);
        }
        
        function createSkyAndClouds() {
            // Create realistic sky
            sky = new Sky();
            sky.scale.setScalar(10000);
            scene.add(sky);

            // Add sun
            sun = new THREE.Vector3();
            
            // More natural sky parameters
            const skyUniforms = sky.material.uniforms;
            skyUniforms['turbidity'].value = 6; // Reduced from 10
            skyUniforms['rayleigh'].value = 1; // Reduced from 2
            skyUniforms['mieCoefficient'].value = 0.003;
            skyUniforms['mieDirectionalG'].value = 0.7;
            
            // Set sun to morning/afternoon position for softer light
            const phi = THREE.MathUtils.degToRad(50); // Sun at 50 degrees elevation
            const theta = THREE.MathUtils.degToRad(160); // Slightly to the side
            
            sun.setFromSphericalCoords(1, phi, theta);
            skyUniforms['sunPosition'].value.copy(sun);
            
            // If we have enough performance budget, add clouds
            if (qualitySettings.quality !== 'low') {
                createClouds();
            }
        }
        
        function createClouds() {
            // Create scattered clouds for daylight scene
            const cloudCount = qualitySettings.quality === 'high' ? 20 : 10;
            
            for (let i = 0; i < cloudCount; i++) {
                const cloudGroup = new THREE.Group();
                
                // Random position
                const angle = Math.random() * Math.PI * 2;
                const radius = 100 + Math.random() * 400;
                const height = 120 + Math.random() * 60;
                
                // Create cloud shape from multiple spheres
                const partCount = qualitySettings.quality === 'high' ? 8 : 4;
                const cloudMaterial = createMaterial('standard', {
                    color: 0xFFFFFF,
                    roughness: 0.9,
                    metalness: 0,
                    transparent: true,
                    opacity: 0.9,
                }, 'cloud');
                
                for (let j = 0; j < partCount; j++) {
                    const size = 15 + Math.random() * 20;
                    const sphereGeometry = getGeometry('sphere', {
                        radius: size,
                        widthSegments: qualitySettings.quality === 'high' ? 16 : 8,
                        heightSegments: qualitySettings.quality === 'high' ? 16 : 8
                    }, qualitySettings.geometryDetail);
                    
                    const cloudPart = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 40
                    );
                    cloudGroup.add(cloudPart);
                }
                
                // Position the cloud in the sky
                cloudGroup.position.set(
                    Math.sin(angle) * radius,
                    height,
                    Math.cos(angle) * radius
                );
                
                // Add slow drifting animation data
                cloudGroup.userData.drift = {
                    speed: 0.05 + Math.random() * 0.1,
                    distance: Math.random() * 20,
                    angle: Math.random() * Math.PI * 2,
                    initialX: cloudGroup.position.x,
                    initialZ: cloudGroup.position.z,
                    time: Math.random() * 1000
                };
                
                scene.add(cloudGroup);
            }
        }
        
        function createEnvironmentalElements() {
            // Add trees, grass, and other natural elements for daylight scene
            const elementCount = qualitySettings.quality === 'high' ? 100 : 
                              qualitySettings.quality === 'medium' ? 60 : 30;
            
            for (let i = 0; i < elementCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 150;
                
                // Don't place elements on the road
                if (Math.abs(Math.sin(angle) * radius) < 10) {
                    continue;
                }
                
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                
                // Randomly create trees or grass clusters
                const elementType = Math.random();
                
                if (elementType > 0.7) {
                    // Create a tree
                    createTree(x, z);
                } else {
                    // Create grass cluster
                    createGrassCluster(x, z);
                }
            }
        }
        
        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            
            // Create trunk
            const trunkGeometry = getGeometry('cylinder', {
                radiusTop: 0.5,
                radiusBottom: 0.8,
                height: 5 + Math.random() * 3,
                radialSegments: 8
            }, qualitySettings.geometryDetail);
            
            const trunkMaterial = createMaterial('standard', {
                color: 0x8B4513, // Brown
                roughness: 0.9,
                metalness: 0.1
            }, 'tree-trunk');
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunk.geometry.parameters.height / 2;
            trunk.castShadow = qualitySettings.shadowsEnabled;
            trunk.receiveShadow = qualitySettings.shadowsEnabled;
            treeGroup.add(trunk);
            
            // Create foliage
            const foliageSegments = qualitySettings.quality === 'high' ? 12 : 8;
            const foliageGeometry = getGeometry('sphere', {
                radius: 3 + Math.random() * 2,
                widthSegments: foliageSegments,
                heightSegments: foliageSegments
            }, qualitySettings.geometryDetail);
            
            const foliageMaterial = createMaterial('standard', {
                color: 0x2E8B57, // Forest green
                roughness: 0.8,
                metalness: 0.1
            }, 'tree-foliage');
            
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = trunk.geometry.parameters.height + 1;
            foliage.castShadow = qualitySettings.shadowsEnabled;
            foliage.receiveShadow = qualitySettings.shadowsEnabled;
            treeGroup.add(foliage);
            
            // Position tree
            treeGroup.position.set(x, 0, z);
            
            // Vary rotation slightly for more natural look
            treeGroup.rotation.y = Math.random() * Math.PI * 2;
            treeGroup.rotation.z = (Math.random() - 0.5) * 0.1;
            
            scene.add(treeGroup);
        }
        
        function createGrassCluster(x, z) {
            // For performance, use instanced meshes for grass when possible
            if (qualitySettings.instancedMeshes) {
                const clusterSize = qualitySettings.quality === 'high' ? 30 : 15;
                const radius = 5 + Math.random() * 3;
                
                // Create single blade geometry to instance
                const bladeGeometry = new THREE.CylinderGeometry(0.05, 0, 1, 3);
                const bladeMaterial = createMaterial('standard', {
                    color: 0x7CCD7C, // Light green
                    roughness: 0.8,
                    metalness: 0.1
                }, 'grass-blade');
                
                const grassInstancedMesh = new THREE.InstancedMesh(
                    bladeGeometry,
                    bladeMaterial,
                    clusterSize
                );
                
                const dummy = new THREE.Object3D();
                
                for (let i = 0; i < clusterSize; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const clusterRadius = Math.random() * radius;
                    
                    // Position within cluster
                    dummy.position.set(
                        x + Math.sin(angle) * clusterRadius,
                        0.5, // Half height
                        z + Math.cos(angle) * clusterRadius
                    );
                    
                    // Random scale and rotation
                    const height = 0.7 + Math.random() * 0.6;
                    dummy.scale.set(1, height, 1);
                    dummy.rotation.set(
                        (Math.random() - 0.5) * 0.2, // Slight tilt
                        Math.random() * Math.PI * 2, // Random rotation
                        (Math.random() - 0.5) * 0.2  // Slight tilt
                    );
                    
                    dummy.updateMatrix();
                    grassInstancedMesh.setMatrixAt(i, dummy.matrix);
                }
                
                grassInstancedMesh.instanceMatrix.needsUpdate = true;
                scene.add(grassInstancedMesh);
                
                // Store for later reference if needed
                if (!instancedObjects.grass) {
                    instancedObjects.grass = [];
                }
                instancedObjects.grass.push(grassInstancedMesh);
                
            } else {
                // Fallback to simpler grass patches for devices without instancing
                const patchGeometry = getGeometry('circle', {
                    radius: 5 + Math.random() * 3,
                    segments: 8
                }, qualitySettings.geometryDetail);
                
                const patchMaterial = createMaterial('standard', {
                    color: 0x7CCD7C, // Light green
                    roughness: 0.8,
                    metalness: 0.1
                }, 'grass-patch');
                
                const grassPatch = new THREE.Mesh(patchGeometry, patchMaterial);
                grassPatch.rotation.x = -Math.PI / 2;
                grassPatch.position.set(x, 0.05, z); // Slightly above ground
                grassPatch.receiveShadow = qualitySettings.shadowsEnabled;
                
                scene.add(grassPatch);
            }
        }
        
        function createRealisticGround() {
            // Skip detailed ground for low quality setting (already created in createEnvironment)
            if (qualitySettings.quality === 'low') return;
            
            // Load textures with proper resolution based on quality
            const textureSize = qualitySettings.textureSize === 'small' ? '512' :
                               qualitySettings.textureSize === 'medium' ? '1024' : '2048';
            
            // Ground textures - using greener grass for daylight 
            const groundBaseTexture = loadTexture(`https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg`);
            const groundNormalMap = loadTexture(`https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-normal.jpg`);
            
            // Road textures
            const roadBaseTexture = loadTexture(`https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/asphalt/asphalt_diffuse.jpg`);
            const roadNormalTexture = loadTexture(`https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/asphalt/asphalt_normal.jpg`);
            const roadRoughnessTexture = loadTexture(`https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/asphalt/asphalt_roughness.jpg`);
            
            // Configure texture settings
            [roadBaseTexture, roadNormalTexture, roadRoughnessTexture,
             groundBaseTexture, groundNormalMap].forEach(texture => {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(100, 100);
            });
            
            // Main ground - optimize geometry detail based on quality
            const groundSegments = qualitySettings.quality === 'medium' ? 50 : 100;
            const groundGeometry = getGeometry('plane', {
                width: 1000, 
                height: 1000, 
                widthSegments: groundSegments, 
                heightSegments: groundSegments
            }, qualitySettings.geometryDetail);
            
            const groundMaterial = createMaterial('standard', {
                map: groundBaseTexture,
                normalMap: groundNormalMap,
                displacementScale: 0.1,
                metalness: 0.1,
                roughness: 0.8,
                envMapIntensity: 1.0
            }, 'ground-detailed');
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = qualitySettings.shadowsEnabled;
            scene.add(ground);
            
            // Enhanced road with realistic asphalt - optimize segments based on quality
            const roadWidthSegments = qualitySettings.quality === 'medium' ? 10 : 20;
            const roadHeightSegments = qualitySettings.quality === 'medium' ? 100 : 200;
            
            const roadGeometry = getGeometry('plane', {
                width: 15, 
                height: 1000, 
                widthSegments: roadWidthSegments, 
                heightSegments: roadHeightSegments
            }, qualitySettings.geometryDetail);
            
            const roadMaterial = createMaterial('standard', {
                map: roadBaseTexture,
                normalMap: roadNormalTexture,
                roughnessMap: roadRoughnessTexture,
                displacementScale: 0.05,
                metalness: 0.1,
                roughness: 0.9
            }, 'road-detailed');
            
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.02;
            road.receiveShadow = qualitySettings.shadowsEnabled;
            scene.add(road);
            
            // Add road markings - white lines visible in daylight
            const centerLineGeometry = getGeometry('plane', {
                width: 0.3,
                height: 1000,
                widthSegments: 1,
                heightSegments: 100
            }, qualitySettings.geometryDetail);
            
            const linesMaterial = createMaterial('standard', {
                color: 0xFFFFFF,
                roughness: 0.8,
                metalness: 0.1,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.1 // Subtle glow
            }, 'road-lines');
            
            const centerLine = new THREE.Mesh(centerLineGeometry, linesMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.03;
            centerLine.receiveShadow = qualitySettings.shadowsEnabled;
            scene.add(centerLine);
            
            // Add dashed lines on sides
            for (let side = -1; side <= 1; side += 2) {
                // Don't create in center
                if (side === 0) continue;
                
                const dashCount = 100;
                const dashLength = 3;
                const gapLength = 5;
                const totalLength = 1000;
                const segmentLength = dashLength + gapLength;
                const segments = Math.floor(totalLength / segmentLength);
                
                for (let i = 0; i < segments; i++) {
                    const dashGeometry = getGeometry('plane', {
                        width: 0.3,
                        height: dashLength,
                        widthSegments: 1,
                        heightSegments: 1
                    }, qualitySettings.geometryDetail);
                    
                    const dash = new THREE.Mesh(dashGeometry, linesMaterial);
                    dash.rotation.x = -Math.PI / 2;
                    dash.position.set(
                        side * 6, // Position at side of road
                        0.03, // Slightly above road
                        -totalLength/2 + i * segmentLength + dashLength/2 // Position along road
                    );
                    dash.receiveShadow = qualitySettings.shadowsEnabled;
                    scene.add(dash);
                }
            }

            // Add terrain variations based on quality
            if (qualitySettings.quality !== 'low') {
                const terrainCountScale = {
                    'medium': 0.5,
                    'high': 1
                };
                
                const terrainCount = Math.floor(20 * terrainCountScale[qualitySettings.quality]);
                
                // Generate terrain in higher quality modes
                for (let i = 0; i < terrainCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 40 + Math.random() * 100;
                    
                    // Don't place terrain variations on the road
                    if (radius < 20) continue;
                    
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius;
                    
                    const size = 10 + Math.random() * 20;
                    const height = Math.random() > 0.5 ? 1 + Math.random() * 2 : -1 - Math.random();
                    
                    const terrainGeometry = getGeometry('circle', { radius: size, segments: 16 });
                    const terrainMaterial = createMaterial('standard', {
                        map: groundBaseTexture,
                        normalMap: groundNormalMap,
                        displacementScale: 0.2,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                    terrain.rotation.x = -Math.PI / 2;
                    terrain.position.set(x, height / 2, z);
                    
                    scene.add(terrain);
                    
                    // Add side walls for raised terrain
                    if (height > 0) {
                        const segments = qualitySettings.quality === 'high' ? 32 : 16;
                        const wallGeometry = getGeometry('cylinder', {
                            radiusTop: size, 
                            radiusBottom: size, 
                            height: height, 
                            radialSegments: segments, 
                            heightSegments: 1, 
                            openEnded: true
                        });
                        
                        const wallMaterial = createMaterial('standard', {
                            map: groundBaseTexture,
                            normalMap: groundNormalMap,
                            roughness: 0.9,
                            metalness: 0.2,
                            side: THREE.DoubleSide
                        });
                        
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x, height / 2, z);
                        scene.add(wall);
                    }
                }
            }
            
            // Add puddles - more visible in daylight as reflective surfaces
            if (qualitySettings.quality !== 'low') {
                // Scale the number of puddles based on quality
                const puddleCountScale = {
                    'medium': 0.5,
                    'high': 1
                };
                
                const puddleCount = Math.floor(20 * puddleCountScale[qualitySettings.quality]);
                
                const puddleGeometry = getGeometry('circle', { radius: 1, segments: 16 });
                const puddleMaterial = createMaterial('standard', {
                    color: 0x7EC0EE, // Light blue for water
                    metalness: 1.0,
                    roughness: 0.1,
                    opacity: 0.7, // Lower for more subtle puddles
                    transparent: true,
                    envMapIntensity: 1.5
                }, 'puddle');
                
                // Use instancing for puddles if supported
                if (qualitySettings.instancedMeshes) {
                    const puddleInstancedMesh = new THREE.InstancedMesh(
                        puddleGeometry, 
                        puddleMaterial, 
                        puddleCount
                    );
                    
                    const dummyPuddle = new THREE.Object3D();
                    
                    for (let i = 0; i < puddleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 20 + Math.random() * 120;
                        
                        const x = Math.sin(angle) * radius;
                        const z = Math.cos(angle) * radius;
                        
                        // Avoid puddles on the road
                        if (Math.abs(x) < 8) continue;
                        
                        const size = 2 + Math.random() * 6;
                        
                        dummyPuddle.position.set(x, 0.05, z);
                        dummyPuddle.rotation.x = -Math.PI / 2;
                        dummyPuddle.scale.set(size, size, 1);
                        dummyPuddle.updateMatrix();
                        puddleInstancedMesh.setMatrixAt(i, dummyPuddle.matrix);
                    }
                    
                    puddleInstancedMesh.instanceMatrix.needsUpdate = true;
                    scene.add(puddleInstancedMesh);
                    
                    // Store for future reference or updates
                    if (!instancedObjects.puddles) {
                        instancedObjects.puddles = [];
                    }
                    instancedObjects.puddles.push(puddleInstancedMesh);
                } else {
                    // Fallback for devices without instancing support - create fewer puddles
                    const reducedPuddleCount = Math.min(10, puddleCount);
                    
                    for (let i = 0; i < reducedPuddleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 20 + Math.random() * 120;
                        
                        const x = Math.sin(angle) * radius;
                        const z = Math.cos(angle) * radius;
                        
                        // Avoid puddles on the road
                        if (Math.abs(x) < 8) continue;
                        
                        const size = 2 + Math.random() * 6;
                        
                        const puddle = new THREE.Mesh(puddleGeometry, puddleMaterial);
                        puddle.rotation.x = -Math.PI / 2;
                        puddle.position.set(x, 0.05, z);
                        puddle.scale.set(size, size, 1);
                        
                        scene.add(puddle);
                    }
                }
            }
        }

        function createVehicles() {
            createCyberpunkCar();
            
            // Create character for walking mode
            character = createCharacter();
            
            // Initialize state variables
            character.userData.walkingAngle = 0;
            character.userData.walkingSpeed = 0;
            character.visible = false;
        }
        
        function createCharacter() {
            const characterGroup = new THREE.Group();
            
            // Reduced polygon count for better performance
            const segments = qualitySettings.quality === 'low' ? 6 : 8;
            
            // Body with reduced geometry
            const bodyGeometry = getGeometry('cylinder', {
                radiusTop: 0.3, 
                radiusBottom: 0.25, 
                height: 1.2, 
                radialSegments: segments
            });
            
            const bodyMaterial = createMaterial('standard', {
                color: 0x3366AA, // Darker blue for better contrast
                metalness: 0.2,
                roughness: 0.8
            }, 'character-body');
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            body.castShadow = qualitySettings.shadowsEnabled;
            characterGroup.add(body);
            
            // Head with reduced geometry
            const headGeometry = getGeometry('sphere', {
                radius: 0.25,
                widthSegments: segments * 2,
                heightSegments: segments
            });
            
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.7;
            head.castShadow = qualitySettings.shadowsEnabled;
            characterGroup.add(head);
            
            // Simplified limbs
            const limbGeometry = getGeometry('cylinder', {
                radiusTop: 0.08, 
                radiusBottom: 0.08, 
                height: 0.8, 
                radialSegments: segments
            });
            
            // Arms
            [-0.4, 0.4].forEach((x, idx) => {
                const arm = new THREE.Mesh(limbGeometry, bodyMaterial);
                arm.position.set(x, 1.1, 0);
                arm.rotation.z = x < 0 ? Math.PI / 6 : -Math.PI / 6;
                arm.castShadow = qualitySettings.shadowsEnabled;
                characterGroup.add(arm);
            });
            
            // Legs
            [-0.2, 0.2].forEach((x, idx) => {
                const leg = new THREE.Mesh(limbGeometry, bodyMaterial);
                leg.position.set(x, 0.4, 0);
                leg.castShadow = qualitySettings.shadowsEnabled;
                characterGroup.add(leg);
            });
            
            // Only add detailed elements if not on mobile
            if (qualitySettings.quality !== 'low') {
                // Add cybernetic details
                const detailGeometry = getGeometry('box', {
                    width: 0.1, 
                    height: 0.2, 
                    depth: 0.1
                });
                
                const detailMaterial = createMaterial('standard', {
                    color: 0x00A3D9, // Bright blue, better for daylight
                    emissive: 0x00A3D9,
                    emissiveIntensity: 0.2 // Reduced for daylight
                }, 'character-detail');
                
                // Simplified tech details
                [
                    { x: 0.15, y: 1.0, z: 0.2 },
                    { x: -0.15, y: 1.0, z: 0.2 }
                ].forEach(pos => {
                    const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                    detail.position.copy(new THREE.Vector3(pos.x, pos.y, pos.z));
                    detail.castShadow = qualitySettings.shadowsEnabled;
                    characterGroup.add(detail);
                });
                
                // Add sunglasses for daylight
                const glassesGeometry = getGeometry('box', {
                    width: 0.3, 
                    height: 0.08, 
                    depth: 0.08
                });
                
                const glassesMaterial = createMaterial('standard', {
                    color: 0x000000,
                    metalness: 0.5,
                    roughness: 0.2
                }, 'character-glasses');
                
                const glasses = new THREE.Mesh(glassesGeometry, glassesMaterial);
                glasses.position.set(0, 1.7, 0.15);
                characterGroup.add(glasses);
            }
            
            // Add to scene but hide initially
            scene.add(characterGroup);
            characterGroup.visible = false;
            
            return characterGroup;
        }
        
        function createCyberpunkCar() {
            const carGroup = new THREE.Group();
            
            // Define materials with proper reuse
            const bodyMaterial = createMaterial('physical', { 
                color: 0xDD0044, // Less saturated red
                metalness: 0.9,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.2,
                emissive: 0x330011,
                emissiveIntensity: 0.05 // Reduced for daylight
            }, 'car-body');
            
            const glassMaterial = createMaterial('physical', { 
                color: 0x001133,
                metalness: 0.2,
                roughness: 0.01,
                transmission: 0.9,
                transparent: true,
                opacity: 0.7,
                envMapIntensity: 1.5
            }, 'car-glass');
            
            // Car body with optimized geometry
            const detailLevel = qualitySettings.geometryDetail;
            
            const bodyGeometry = getGeometry('box', {
                width: 2.2, 
                height: 0.8, 
                depth: 5,
                widthSegments: 1,
                heightSegments: 1,
                depthSegments: 1
            }, detailLevel);
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = qualitySettings.shadowsEnabled;
            carGroup.add(body);
            
            // Car roof with advanced shape (simplified for lower quality settings)
            if (qualitySettings.quality === 'low') {
                // Simple roof for low quality
                const simpleRoofGeometry = getGeometry('box', {
                    width: 1.8,
                    height: 0.8,
                    depth: 2.6
                }, detailLevel);
                
                const roof = new THREE.Mesh(simpleRoofGeometry, bodyMaterial);
                roof.position.set(0, 0.9, 0.1);
                roof.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(roof);
            } else {
                // More detailed roof with shape extrusion
                const roofPoints = [];
                roofPoints.push(new THREE.Vector2(-0.9, -1.2)); // Bottom left
                roofPoints.push(new THREE.Vector2(-0.9, 1.0));  // Top left
                roofPoints.push(new THREE.Vector2(-0.5, 1.4));  // Top left corner
                roofPoints.push(new THREE.Vector2(0.5, 1.4));   // Top right corner
                roofPoints.push(new THREE.Vector2(0.9, 1.0));   // Top right
                roofPoints.push(new THREE.Vector2(0.9, -1.2));  // Bottom right
                
                const roofShape = new THREE.Shape(roofPoints);
                const extrudeSettings = {
                    steps: 1,
                    depth: 0.8,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelSegments: qualitySettings.quality === 'high' ? 3 : 2
                };
                
                const roofGeometry = new THREE.ExtrudeGeometry(roofShape, extrudeSettings);
                roofGeometry.rotateX(-Math.PI / 2);
                
                const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
                roof.position.set(0, 0.9, 0);
                roof.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(roof);
            }
            
            // Windshield and windows
            const glassGeometry = getGeometry('plane', {
                width: 1.8,
                height: 0.9
            }, detailLevel);
            
            // Front windshield
            const frontGlass = new THREE.Mesh(glassGeometry, glassMaterial);
            frontGlass.position.set(0, 1.15, 1.25);
            frontGlass.rotation.x = Math.PI / 4;
            carGroup.add(frontGlass);
            
            // Rear windshield
            const rearGlass = new THREE.Mesh(glassGeometry, glassMaterial);
            rearGlass.position.set(0, 1.15, -1.25);
            rearGlass.rotation.x = -Math.PI / 4;
            carGroup.add(rearGlass);
            
            // Advanced wheels with suspension system
            const wheelPositions = [
                { x: -1.2, y: 0.4, z: 1.6 },
                { x: 1.2, y: 0.4, z: 1.6 },
                { x: -1.2, y: 0.4, z: -1.6 },
                { x: 1.2, y: 0.4, z: -1.6 }
            ];
            
            // Create wheels with reused materials and geometries
            const tireMaterial = createMaterial('standard', { 
                color: 0x111111, 
                roughness: 0.9,
                metalness: 0.1
            }, 'car-tire');
            
            const rimMaterial = createMaterial('standard', { 
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.1,
                emissive: 0x222222
            }, 'car-rim');
            
            // Optimize wheel geometry based on quality
            const wheelSegments = qualitySettings.quality === 'low' ? 8 : 16;
            
            const tireGeometry = getGeometry('cylinder', {
                radiusTop: 0.4,
                radiusBottom: 0.4,
                height: 0.3,
                radialSegments: wheelSegments
            }, detailLevel);
            
            const rimGeometry = getGeometry('cylinder', {
                radiusTop: 0.25,
                radiusBottom: 0.25,
                height: 0.32,
                radialSegments: wheelSegments / 2
            }, detailLevel);
            
            wheelPositions.forEach(pos => {
                // Wheel systems with multiple parts
                const wheelGroup = new THREE.Group();
                
                // Tire
                const tire = new THREE.Mesh(tireGeometry, tireMaterial);
                tire.rotation.z = Math.PI / 2;
                tire.castShadow = qualitySettings.shadowsEnabled;
                wheelGroup.add(tire);
                
                // Rim
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.rotation.z = Math.PI / 2;
                wheelGroup.add(rim);
                
                // Add spokes (optimized for quality settings)
                if (qualitySettings.quality !== 'low') {
                    const spokeGeometry = getGeometry('box', {
                        width: 0.04,
                        height: 0.04,
                        depth: 0.5
                    }, detailLevel);
                    
                    const spokeCount = qualitySettings.quality === 'high' ? 5 : 3;
                    
                    for (let i = 0; i < spokeCount; i++) {
                        const spoke = new THREE.Mesh(spokeGeometry, rimMaterial);
                        spoke.rotation.z = (i / spokeCount) * Math.PI * 2;
                        rim.add(spoke);
                    }
                }
                
                // Brake caliper (only add for medium/high quality)
                if (qualitySettings.quality !== 'low') {
                    const caliperGeometry = getGeometry('box', {
                        width: 0.1,
                        height: 0.3,
                        depth: 0.15
                    }, detailLevel);
                    
                    const caliperMaterial = createMaterial('standard', { 
                        color: 0xCC0000, // Less saturated red for daylight
                        metalness: 0.7,
                        roughness: 0.3
                    }, 'car-caliper');
                    
                    const caliper = new THREE.Mesh(caliperGeometry, caliperMaterial);
                    caliper.position.z = 0.2;
                    wheelGroup.add(caliper);
                }
                
                // Wheel glow effect (when boosting) - less intense for daylight
                if (qualitySettings.effectsLevel !== 'minimal') {
                    const glowGeometry = getGeometry('ring', {
                        innerRadius: 0.4,
                        outerRadius: 0.45,
                        thetaSegments: wheelSegments
                    }, detailLevel);
                    
                    const glowMaterial = createMaterial('basic', {
                        color: 0x00A3D9, // Better color for daylight
                        transparent: true,
                        opacity: 0.0,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    }, 'car-wheel-glow');
                    
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.rotation.y = Math.PI / 2;
                    wheelGroup.add(glow);
                    
                    // Store reference to glow for animation
                    glow.userData.material = glowMaterial;
                }
                
                wheelGroup.position.set(pos.x, pos.y, pos.z);
                wheelGroup.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(wheelGroup);
                
                // Store wheels for animation
                wheelGroup.userData.isWheel = true;
            });
            
            // Add neon underlight (only for medium/high quality)
            if (qualitySettings.effectsLevel !== 'minimal') {
                const underlightGeometry = getGeometry('plane', {
                    width: 2,
                    height: 5
                }, detailLevel);
                
                underlightGeometry.rotateX(-Math.PI / 2);
                
                const underlightMaterial = createShaderMaterial({
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x00A3D9) }, // Better color for daylight
                    intensity: { value: 0.15 } // Reduced for daylight
                }, 
                // Vertex Shader
                `
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment Shader
                `
                    uniform float time;
                    uniform vec3 color;
                    uniform float intensity;
                    varying vec2 vUv;
                    
                    void main() {
                        float alpha = (1.0 - vUv.y) * intensity;
                        alpha *= 0.8 + 0.2 * sin(time * 5.0 + vUv.x * 20.0);
                        
                        // Fade out at edges
                        alpha *= smoothstep(0.0, 0.1, vUv.x) * smoothstep(1.0, 0.9, vUv.x);
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                {
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const underlight = new THREE.Mesh(underlightGeometry, underlightMaterial);
                underlight.position.y = 0.05;
                carGroup.add(underlight);
                
                // Store reference for shader updates
                neonSigns.push(underlight);
            }
            
            // Headlights with optimized complexity based on quality
            [-0.8, 0.8].forEach(x => {
                // Main headlight
                const headlightGeometry = getGeometry('cylinder', {
                    radiusTop: 0.15,
                    radiusBottom: 0.2,
                    height: 0.1,
                    radialSegments: qualitySettings.quality === 'low' ? 8 : 16
                }, detailLevel);
                
                headlightGeometry.rotateX(Math.PI / 2);
                
                const headlightMaterial = createMaterial('standard', {
                    color: 0xFFFFCC, // Warmer color for daylight
                    emissive: 0xFFFFCC,
                    emissiveIntensity: 0.2 // Lower intensity for daylight
                }, 'car-headlight');
                
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(x, 0.6, 2.55);
                carGroup.add(headlight);
                
                // Add headlight light source
                if (cityLights.length < qualitySettings.maxLights) {
                    const light = new THREE.SpotLight(0xFFFFCC, 0.5, 40, Math.PI / 6, 0.5, 1); // Reduced intensity
                    light.position.set(x, 0.6, 2.55);
                    light.target.position.set(x, 0.6, 5);
                    carGroup.add(light);
                    carGroup.add(light.target);
                    
                    // Store for performance tracking
                    cityLights.push(light);
                }
            });
            
            // Taillights - simplified for low quality
            [-0.8, 0.8].forEach(x => {
                const taillight = new THREE.Mesh(
                    getGeometry('box', {
                        width: 0.3,
                        height: 0.15,
                        depth: 0.05
                    }, detailLevel),
                    createMaterial('standard', {
                        color: 0xCC0000, // Less saturated red
                        emissive: 0xCC0000,
                        emissiveIntensity: 0.2 // Lower for daylight
                    }, 'car-taillight')
                );
                
                taillight.position.set(x, 0.6, -2.55);
                carGroup.add(taillight);
            });
            
            // Only add detail features for medium/high quality
            if (qualitySettings.quality !== 'low') {
                // Add aerodynamic fins
                const finGeometry = getGeometry('box', {
                    width: 0.1,
                    height: 0.4,
                    depth: 1.2
                }, detailLevel);
                
                const finMaterial = createMaterial('standard', {
                    color: 0xDD0044, // Less saturated red
                    metalness: 0.9,
                    roughness: 0.2
                }, 'car-fin');
                
                const rearFin = new THREE.Mesh(finGeometry, finMaterial);
                rearFin.position.set(0, 0.9, -2);
                rearFin.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(rearFin);
                
                // Add cyberpunk details - antenna, sensors, etc.
                const antennaGeometry = getGeometry('cylinder', {
                    radiusTop: 0.02,
                    radiusBottom: 0.02,
                    height: 0.6,
                    radialSegments: 8
                }, detailLevel);
                
                const antennaMaterial = createMaterial('standard', {
                    color: 0x888888,
                    metalness: 0.9,
                    roughness: 0.1
                }, 'car-antenna');
                
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(-0.8, 1.4, -1.5);
                antenna.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(antenna);
                
                const antennaTip = new THREE.Mesh(
                    getGeometry('sphere', {
                        radius: 0.04,
                        widthSegments: 8,
                        heightSegments: 8
                    }, detailLevel),
                    createMaterial('basic', {
                        color: 0xCC0000 // Less saturated red
                    }, 'car-antenna-tip')
                );
                
                antennaTip.position.set(0, 0.35, 0);
                antenna.add(antennaTip);
                
                // Solar panel on roof for daylight version
                const solarPanelGeometry = getGeometry('box', {
                    width: 1.5,
                    height: 0.05,
                    depth: 1.0
                }, detailLevel);
                
                const solarPanelMaterial = createMaterial('physical', {
                    color: 0x2244AA,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                }, 'car-solar-panel');
                
                const solarPanel = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
                solarPanel.position.set(0, 1.85, 0);
                solarPanel.castShadow = qualitySettings.shadowsEnabled;
                carGroup.add(solarPanel);
                
                // Add grid pattern to solar panel
                const gridGeometry = getGeometry('plane', {
                    width: 1.45,
                    height: 0.95
                }, detailLevel);
                
                // Create grid texture
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Draw dark blue background
                ctx.fillStyle = '#1a3366';
                ctx.fillRect(0, 0, 256, 256);
                
                // Draw grid lines
                ctx.strokeStyle = '#3366cc';
                ctx.lineWidth = 2;
                
                // Vertical lines
                for (let x = 16; x < 256; x += 16) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, 256);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 16; y < 256; y += 16) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(256, y);
                    ctx.stroke();
                }
                
                const gridTexture = new THREE.CanvasTexture(canvas);
                const gridMaterial = createMaterial('basic', {
                    map: gridTexture,
                    transparent: true,
                    opacity: 0.8
                });
                
                const grid = new THREE.Mesh(gridGeometry, gridMaterial);
                grid.position.set(0, 0.03, 0);
                grid.rotation.x = -Math.PI / 2;
                solarPanel.add(grid);
            }
            
            car = carGroup;
            car.position.set(0, 0, 50);
            car.castShadow = qualitySettings.shadowsEnabled;
            car.receiveShadow = false;
            scene.add(car);
        }

        function createPortfolioSections() {
            // Create reusable geometries
            const buildingGeoCache = {};
            
            // Create a single template mesh for each building type
            function getBuildingGeometry(type, params) {
                const cacheKey = `${type}-${JSON.stringify(params)}`;
                
                if (buildingGeoCache[cacheKey]) {
                    return buildingGeoCache[cacheKey];
                }
                
                let geometry;
                
                switch(type) {
                    case 'box':
                        geometry = getGeometry('box', params, qualitySettings.geometryDetail);
                        break;
                    case 'cylinder':
                        geometry = getGeometry('cylinder', params, qualitySettings.geometryDetail);
                        break;
                    case 'cone':
                        geometry = getGeometry('cone', params, qualitySettings.geometryDetail);
                        break;
                    case 'sphere':
                        geometry = getGeometry('sphere', params, qualitySettings.geometryDetail);
                        break;
                }
                
                buildingGeoCache[cacheKey] = geometry;
                return geometry;
            }
            
            // Create building base materials with reduced emission for daylight
            function createBuildingMaterial(color, intensity) {
                const cacheKey = `building-${color}-${intensity}`;
                
                return createMaterial('physical', {
                    color: color,
                    metalness: 0.6,
                    roughness: 0.4,
                    emissive: color,
                    emissiveIntensity: intensity * 0.2, // Significantly reduced for daylight
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.4
                }, cacheKey);
            }
            
            // Process each section with optimized creation
            Object.entries(portfolioData).forEach(([title, data]) => {
                const sectionGroup = new THREE.Group();
                
                // Randomize building style for variety
                const buildingType = Math.floor(Math.random() * 4);
                const height = 20 + Math.random() * 30;
                
                // Create base building with cyberpunk style
                let buildingMesh;
                
                switch(buildingType) {
                    case 0: // Skyscraper style
                        buildingMesh = createSkyscraper(data.color, height);
                        break;
                    case 1: // Dome structure
                        buildingMesh = createDomeBuilding(data.color, height);
                        break;
                    case 2: // Pyramid structure
                        buildingMesh = createPyramidBuilding(data.color, height);
                        break;
                    case 3: // Holographic tower
                        buildingMesh = createHolographicTower(data.color, height);
                        break;
                }
                
                sectionGroup.add(buildingMesh);
                
                // Add holographic projection above building
                if (qualitySettings.effectsLevel !== 'minimal') {
                    const holoProjection = createHolographicProjection(title, data.color);
                    holoProjection.position.y = height + 10;
                    sectionGroup.add(holoProjection);
                    hologramProjections.push(holoProjection);
                } else {
                    // Add simple sign for minimal effects mode
                    const signGeometry = getGeometry('plane', { width: 6, height: 2 });
                    
                    // Create canvas texture for sign
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw sign text with better contrast for daylight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(0, 0, 512, 128);
                    ctx.fillStyle = `rgb(
                        ${Math.min(255, ((data.color >> 16) & 255) * 0.8)},
                        ${Math.min(255, ((data.color >> 8) & 255) * 0.8)},
                        ${Math.min(255, (data.color & 255) * 0.8)}
                    )`;
                    ctx.font = 'bold 60px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(title.toUpperCase(), 256, 64);
                    
                    const signTexture = new THREE.CanvasTexture(canvas);
                    const signMaterial = createMaterial('basic', {
                        map: signTexture,
                        side: THREE.DoubleSide
                    });
                    
                    const sign = new THREE.Mesh(signGeometry, signMaterial);
                    sign.position.set(0, height + 5, 0);
                    sign.lookAt(0, height, 0); // Always face the center
                    sectionGroup.add(sign);
                }
                
                // Add entrance portal with interactive elements
                const portalGeometry = getGeometry('box', { 
                    width: 5, 
                    height: 8, 
                    depth: 1 
                }, qualitySettings.geometryDetail);
                
                const portalMaterial = createShaderMaterial({
                    time: { value: 0 },
                    color: { value: new THREE.Color(data.color) }
                }, 
                // Vertex shader
                `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment shader (optimized for daylight)
                `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 center = vUv - vec2(0.5);
                        float dist = length(center);
                        
                        // Create portal effect (simplified)
                        float ripple = sin(dist * 20.0 - time * 3.0) * 0.5 + 0.5;
                        ripple *= smoothstep(0.5, 0.4, dist);
                        
                        // Energy edges 
                        float edge = smoothstep(0.5, 0.45, dist) - smoothstep(0.45, 0.4, dist);
                        
                        // Combine effects - brighter colors for daylight visibility
                        vec3 finalColor = mix(
                            color * 0.7, // Less dark base
                            color * 1.3, // Brighter highlights
                            ripple + edge
                        );
                        
                        float alpha = smoothstep(0.5, 0.4, dist) * 0.8; // More opacity for visibility
                        alpha = mix(alpha, 1.0, edge);
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                {
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.NormalBlending
                });
                
                const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                portal.position.set(0, 4, 8); // Position at front of building
                sectionGroup.add(portal);
                
                // Store portal for animation updates
                neonSigns.push(portal);
                
                // Add energy field around building (only for high effects)
                if (qualitySettings.effectsLevel === 'ultra') {
                    const energyField = createEnergyField(data.color);
                    energyField.scale.set(12, height * 0.6, 12);
                    energyField.position.y = height * 0.3;
                    sectionGroup.add(energyField);
                }
                
                // Position section according to data
                sectionGroup.position.set(data.position.x, 0, data.position.z);
                sectionGroup.userData = { 
                    title, 
                    content: data.content,
                    color: data.color
                };
                
                sections.push(sectionGroup);
                buildings.push(sectionGroup);
                scene.add(sectionGroup);
            });

            // Helper functions for building creation
            function createSkyscraper(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base structure
                const baseGeometry = getBuildingGeometry('box', {
                    width: 10, 
                    height: height, 
                    depth: 10
                });
                
                const baseMaterial = createBuildingMaterial(color, 0.1); // Reduced for daylight
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = height / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Only add detailed features for higher quality settings
                if (qualitySettings.quality !== 'low') {
                    // Add setbacks for futuristic look
                    const setbackHeights = [0.6, 0.75, 0.85];
                    setbackHeights.forEach(h => {
                        const setbackSize = 8 - (h * 4);
                        const setbackHeight = height * 0.15;
                        
                        const setbackGeometry = getBuildingGeometry('box', {
                            width: setbackSize, 
                            height: setbackHeight, 
                            depth: setbackSize
                        });
                        
                        const setbackMaterial = createBuildingMaterial(color, 0.15); // Reduced for daylight
                        const setback = new THREE.Mesh(setbackGeometry, setbackMaterial);
                        setback.position.y = height * h;
                        setback.castShadow = qualitySettings.shadowsEnabled;
                        group.add(setback);
                    });
                    
                    // Add spire
                    const spireGeometry = getBuildingGeometry('cone', {
                        radius: 1,
                        height: height * 0.2,
                        radialSegments: 4
                    });
                    
                    const spireMaterial = createMaterial('standard', {
                        color: 0xaaaaaa,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: color,
                        emissiveIntensity: 0.1 // Reduced for daylight
                    }, 'building-spire');
                    
                    const spire = new THREE.Mesh(spireGeometry, spireMaterial);
                    spire.position.y = height * 1.1;
                    spire.castShadow = qualitySettings.shadowsEnabled;
                    group.add(spire);
                    
                    // Add glass windows for daylight reflection
                    const segments = height / 3;  // One window every 3 units
                    const windowGeometry = getGeometry('plane', {
                        width: 0.8,
                        height: 1.0
                    }, detailLevel);
                    
                    const windowMaterial = createMaterial('physical', {
                        color: 0x88CCFF,
                        metalness: 0.9,
                        roughness: 0.1,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1,
                        envMapIntensity: 1.0
                    }, 'building-window');
                    
                    // Create windows on all four sides
                    for (let side = 0; side < 4; side++) {
                        const angle = (side / 4) * Math.PI * 2;
                        const offsetX = Math.sin(angle) * 5.01;
                        const offsetZ = Math.cos(angle) * 5.01;
                        
                        for (let i = 1; i < segments; i++) {
                            // Skip some windows randomly for variation
                            if (Math.random() > 0.7) continue;
                            
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            window.position.set(
                                offsetX,
                                i * 3 + Math.random() * 0.5,
                                offsetZ
                            );
                            window.rotation.y = -angle; // Face outward
                            group.add(window);
                        }
                    }
                    
                    // Add solar panels for daylight version
                    const panelGeometry = getGeometry('box', {
                        width: 2, 
                        height: 0.1, 
                        depth: 3
                    }, detailLevel);
                    
                    const panelMaterial = createMaterial('physical', {
                        color: 0x2244AA,
                        metalness: 0.9,
                        roughness: 0.1,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1
                    }, 'building-solar');
                    
                    for (let i = 0; i < 3; i++) {
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        panel.position.set(
                            -3 + i * 3,
                            height * 0.95,
                            -3
                        );
                        panel.rotation.x = Math.PI / 6; // Tilt toward sun
                        panel.castShadow = qualitySettings.shadowsEnabled;
                        group.add(panel);
                    }
                }
                
                return group;
            }
            
            function createDomeBuilding(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base structure
                const baseHeight = height * 0.7;
                const baseSegments = qualitySettings.quality === 'low' ? 8 : 16;
                
                const baseGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 8,
                    radiusBottom: 10,
                    height: baseHeight,
                    radialSegments: baseSegments
                });
                
                const baseMaterial = createBuildingMaterial(color, 0.1); // Reduced for daylight
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = baseHeight / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Dome
                const domeSegments = qualitySettings.quality === 'low' ? 16 : 
                                     qualitySettings.quality === 'medium' ? 24 : 32;
                
                const domeGeometry = getBuildingGeometry('sphere', {
                    radius: 8,
                    widthSegments: domeSegments,
                    heightSegments: domeSegments / 2,
                    phiStart: 0, 
                    phiLength: Math.PI * 2,
                    thetaStart: 0, 
                    thetaLength: Math.PI / 2
                });
                
                const domeMaterial = createMaterial('physical', {
                    color: color,
                    metalness: 0.4,
                    roughness: 0.1,
                    transmission: 0.6,
                    thickness: 0.5,
                    envMapIntensity: 1.5,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                }, `dome-${color}`);
                
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = baseHeight;
                dome.castShadow = qualitySettings.shadowsEnabled;
                group.add(dome);
                
                // Add support structures for detail - skip for low quality
                if (qualitySettings.quality !== 'low') {
                    // Scale number of supports based on quality
                    const supportCount = qualitySettings.quality === 'high' ? 6 : 4;
                    
                    for (let i = 0; i < supportCount; i++) {
                        const angle = (i / supportCount) * Math.PI * 2;
                        const supportGeometry = getBuildingGeometry('box', {
                            width: 1, 
                            height: baseHeight, 
                            depth: 1
                        });
                        
                        const supportMaterial = createMaterial('standard', {
                            color: 0xaaaaaa,
                            metalness: 0.8,
                            roughness: 0.2
                        }, 'building-support');
                        
                        const support = new THREE.Mesh(supportGeometry, supportMaterial);
                        support.position.set(
                            Math.sin(angle) * 8,
                            baseHeight / 2,
                            Math.cos(angle) * 8
                        );
                        support.castShadow = qualitySettings.shadowsEnabled;
                        group.add(support);
                    }
                    
                    // Add windows along the base
                    const windowCount = Math.floor(baseHeight / 3);
                    const windowGeometry = getGeometry('plane', {
                        width: 0.8,
                        height: 1.0
                    }, detailLevel);
                    
                    const windowMaterial = createMaterial('physical', {
                        color: 0x88CCFF,
                        metalness: 0.9,
                        roughness: 0.1,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1,
                        envMapIntensity: 1.0
                    }, 'building-window');
                    
                    // Place windows in a ring around the building
                    for (let i = 0; i < 24; i++) {
                        const angle = (i / 24) * Math.PI * 2;
                        
                        for (let j = 1; j <= windowCount; j++) {
                            // Skip some windows randomly
                            if (Math.random() > 0.6) continue;
                            
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            window.position.set(
                                Math.sin(angle) * 10.01, // Just outside base
                                j * 3,
                                Math.cos(angle) * 10.01
                            );
                            window.rotation.y = -angle; // Face outward
                            group.add(window);
                        }
                    }
                }
                
                return group;
            }
            
            function createPyramidBuilding(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base
                const baseHeight = height * 0.3;
                const baseSegments = qualitySettings.quality === 'low' ? 1 : 2;
                
                const baseGeometry = getBuildingGeometry('box', {
                    width: 16, 
                    height: baseHeight, 
                    depth: 16,
                    widthSegments: baseSegments,
                    heightSegments: baseSegments,
                    depthSegments: baseSegments
                });
                
                const baseMaterial = createBuildingMaterial(color, 0.1); // Reduced for daylight
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = baseHeight / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Pyramid
                const pyramidHeight = height * 0.7;
                const pyramidSegments = qualitySettings.quality === 'low' ? 4 : 
                                       qualitySettings.quality === 'medium' ? 6 : 8;
                
                const pyramidGeometry = getBuildingGeometry('cone', {
                    radius: 8, 
                    height: pyramidHeight, 
                    radialSegments: 4,
                    heightSegments: pyramidSegments
                });
                
                const pyramidMaterial = createBuildingMaterial(color, 0.15); // Reduced for daylight
                const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                pyramid.position.y = baseHeight + pyramidHeight / 2;
                pyramid.castShadow = qualitySettings.shadowsEnabled;
                group.add(pyramid);
                
                // Add solar panels on pyramid faces for daylight
                if (qualitySettings.quality !== 'low') {
                    // Create a solar panel on each face
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        
                        // Calculate position on pyramid face
                        const panelHeight = baseHeight + pyramidHeight * 0.6;
                        const distanceFromCenter = 3; // How far from center axis
                        
                        const panelGeometry = getGeometry('plane', {
                            width: 3,
                            height: 4
                        }, detailLevel);
                        
                        const panelMaterial = createMaterial('physical', {
                            color: 0x2244AA,
                            metalness: 0.9,
                            roughness: 0.1,
                            envMapIntensity: 1.0,
                            clearcoat: 1.0,
                            clearcoatRoughness: 0.1
                        }, 'pyramid-solar-panel');
                        
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        
                        // Position and rotate to align with pyramid face
                        panel.position.set(
                            Math.sin(angle) * distanceFromCenter,
                            panelHeight,
                            Math.cos(angle) * distanceFromCenter
                        );
                        
                        // Rotate to align with pyramid face
                        panel.lookAt(new THREE.Vector3(
                            Math.sin(angle) * 8,
                            baseHeight,
                            Math.cos(angle) * 8
                        ));
                        
                        // Adjust rotation to face more toward the sun
                        panel.rotation.x += Math.PI / 12;
                        
                        panel.castShadow = qualitySettings.shadowsEnabled;
                        group.add(panel);
                    }
                    
                    // Add tip cap
                    const capGeometry = getBuildingGeometry('cylinder', {
                        radiusTop: 0.5,
                        radiusBottom: 1.2,
                        height: 1.5,
                        radialSegments: 8
                    }, detailLevel);
                    
                    const capMaterial = createMaterial('standard', {
                        color: 0x888888,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: color,
                        emissiveIntensity: 0.15 // Reduced for daylight
                    }, 'pyramid-cap');
                    
                    const cap = new THREE.Mesh(capGeometry, capMaterial);
                    cap.position.y = baseHeight + pyramidHeight + 0.75;
                    cap.castShadow = qualitySettings.shadowsEnabled;
                    group.add(cap);
                    
                    // Add antenna
                    const antennaGeometry = getBuildingGeometry('cylinder', {
                        radiusTop: 0.05,
                        radiusBottom: 0.1,
                        height: 3,
                        radialSegments: 8
                    }, detailLevel);
                    
                    const antenna = new THREE.Mesh(antennaGeometry, capMaterial);
                    antenna.position.y = baseHeight + pyramidHeight + 3;
                    antenna.castShadow = qualitySettings.shadowsEnabled;
                    group.add(antenna);
                    
                    // Add antenna tip
                    const tipGeometry = getBuildingGeometry('sphere', {
                        radius: 0.2,
                        widthSegments: 8,
                        heightSegments: 8
                    }, detailLevel);
                    
                    const tipMaterial = createMaterial('standard', {
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2, // Reduced but still visible in daylight
                        metalness: 0.9,
                        roughness: 0.1
                    }, 'antenna-tip');
                    
                    const tip = new THREE.Mesh(tipGeometry, tipMaterial);
                    tip.position.y = baseHeight + pyramidHeight + 4.5;
                    group.add(tip);
                }
                
                return group;
            }
            
            function createHolographicTower(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Core structure (physical part)
                const coreHeight = height * 0.8;
                const segments = qualitySettings.quality === 'low' ? 6 : 8;
                
                const coreGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 2, 
                    radiusBottom: 4, 
                    height: coreHeight,
                    radialSegments: segments
                });
                
                const coreMaterial = createMaterial('standard', {
                    color: 0x555555, // Lighter for daylight
                    metalness: 0.9,
                    roughness: 0.2
                }, 'tower-core');
                
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = coreHeight / 2;
                core.castShadow = qualitySettings.shadowsEnabled;
                core.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(core);
                
                // Add windows along the tower
                if (qualitySettings.quality !== 'low') {
                    const windowGeometry = getGeometry('plane', {
                        width: 0.6,
                        height: 1.0
                    }, detailLevel);
                    
                    const windowMaterial = createMaterial('physical', {
                        color: 0x88CCFF,
                        metalness: 0.9,
                        roughness: 0.1,
                        clearcoat: 1.0,
                        envMapIntensity: 1.0
                    }, 'tower-window');
                    
                    // Windows around the tower
                    const windowRows = Math.floor(coreHeight / 2.5);
                    const windowsPerRow = 8;
                    
                    for (let row = 1; row <= windowRows; row++) {
                        const y = row * 2.5;
                        const radius = 2 + (coreHeight - y) / coreHeight * 2; // Tapers toward top
                        
                        for (let i = 0; i < windowsPerRow; i++) {
                            const angle = (i / windowsPerRow) * Math.PI * 2;
                            
                            // Skip some windows randomly
                            if (Math.random() > 0.7) continue;
                            
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            window.position.set(
                                Math.sin(angle) * radius,
                                y,
                                Math.cos(angle) * radius
                            );
                            window.rotation.y = -angle; // Face outward
                            group.add(window);
                        }
                    }
                    
                    // Add emitters along tower - visible but less bright in daylight
                    const emitterCount = Math.min(4, Math.floor(coreHeight / 6));
                    
                    for (let i = 0; i < emitterCount; i++) {
                        const emitterY = (i + 1) * (coreHeight / (emitterCount + 1));
                        
                        const emitterGeometry = getGeometry('box', {
                            width: 0.5,
                            height: 0.5,
                            depth: 0.5
                        }, detailLevel);
                        
                        const emitterMaterial = createMaterial('standard', {
                            color: color,
                            emissive: color,
                            emissiveIntensity: 0.2, // Visible in daylight
                            metalness: 0.5,
                            roughness: 0.2
                        }, `emitter-${color}`);
                        
                        // Add emitters on cardinal directions
                        for (let j = 0; j < 4; j++) {
                            const angle = (j / 4) * Math.PI * 2;
                            const radius = 2 + (coreHeight - emitterY) / coreHeight * 2; // Tapers like windows
                            
                            const emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
                            emitter.position.set(
                                Math.sin(angle) * (radius + 0.1),
                                emitterY,
                                Math.cos(angle) * (radius + 0.1)
                            );
                            group.add(emitter);
                        }
                    }
                }
                
                // Add top cap
                const capGeometry = getBuildingGeometry('sphere', {
                    radius: 2,
                    widthSegments: qualitySettings.quality === 'low' ? 8 : 16,
                    heightSegments: qualitySettings.quality === 'low' ? 8 : 16
                });
                
                const capMaterial = createMaterial('standard', {
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2, // Reduced for daylight
                    metalness: 0.6,
                    roughness: 0.2
                }, `cap-sphere-${color}`);
                
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = coreHeight;
                cap.castShadow = qualitySettings.shadowsEnabled;
                group.add(cap);
                
                // Add base emitter disk
                const diskGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 8, 
                    radiusBottom: 8, 
                    height: 0.5,
                    radialSegments: qualitySettings.quality === 'low' ? 16 : 32
                });
                
                const diskMaterial = createMaterial('standard', {
                    color: 0x333333,
                    emissive: color,
                    emissiveIntensity: 0.15, // Reduced for daylight
                    metalness: 0.8,
                    roughness: 0.2
                }, `disk-${color}`);
                
                const disk = new THREE.Mesh(diskGeometry, diskMaterial);
                disk.position.y = 0.25;
                disk.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(disk);
                
                // Add solar panels around base for daylight version
                if (qualitySettings.quality !== 'low') {
                    const panelCount = qualitySettings.quality === 'high' ? 6 : 4;
                    const panelGeometry = getGeometry('box', {
                        width: 3,
                        height: 0.1,
                        depth: 2
                    }, detailLevel);
                    
                    const panelMaterial = createMaterial('physical', {
                        color: 0x2244AA,
                        metalness: 0.9,
                        roughness: 0.1,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1
                    }, 'tower-solar-panel');
                    
                    for (let i = 0; i < panelCount; i++) {
                        const angle = (i / panelCount) * Math.PI * 2;
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        
                        panel.position.set(
                            Math.sin(angle) * 6,
                            0.5,
                            Math.cos(angle) * 6
                        );
                        
                        panel.rotation.set(
                            Math.PI / 6, // Tilt toward sun
                            angle, // Face outward from center
                            0
                        );
                        
                        panel.castShadow = qualitySettings.shadowsEnabled;
                        panel.receiveShadow = qualitySettings.shadowsEnabled;
                        group.add(panel);
                    }
                }
                
                return group;
            }
            
            function createEnergyField(color) {
                // Only create for high quality settings
                const detailLevel = qualitySettings.geometryDetail;
                
                const geometry = getBuildingGeometry('sphere', {
                    radius: 1,
                    widthSegments: qualitySettings.quality === 'high' ? 32 : 16,
                    heightSegments: qualitySettings.quality === 'high' ? 16 : 8
                });
                
                const material = createShaderMaterial({
                    time: { value: 0 },
                    color: { value: new THREE.Color(color) }
                },
                // Vertex shader
                `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment shader (brighter for daylight)
                `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0))), 3.0);
                        fresnel = mix(0.1, 1.0, fresnel);
                        
                        float pulse = 0.7 + 0.3 * sin(time * 3.0);
                        
                        // Create simplified energy pattern
                        float grid = max(
                            step(0.98, sin(vUv.y * 20.0 + time)),
                            step(0.98, sin(vUv.x * 20.0 + time))
                        );
                        
                        // Brighter colors for daylight visibility
                        vec3 finalColor = color * fresnel * pulse * 1.2;
                        finalColor = mix(finalColor, vec3(1.0), grid * 0.7);
                        
                        float alpha = 0.1 * fresnel * pulse; // Reduced for subtlety
                        alpha = mix(alpha, 0.7, grid);
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                {
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                
                // Store for shader updates
                neonSigns.push(sphere);
                
                return sphere;
            }
            
            function createHolographicProjection(title, color) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base emitter
                const emitterGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 2, 
                    radiusBottom: 2, 
                    height: 0.5,
                    radialSegments: qualitySettings.quality === 'low' ? 8 : 16
                });
                
                const emitterMaterial = createMaterial('standard', {
                    color: 0x555555,
                    emissive: color,
                    emissiveIntensity: 0.15, // Reduced for daylight
                    metalness: 0.8,
                    roughness: 0.2
                }, `emitter-${color}`);
                
                const emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
                emitter.position.y = -0.25;
                emitter.castShadow = qualitySettings.shadowsEnabled;
                group.add(emitter);
                
                // Holographic text
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 1024;
                textCanvas.height = 256;
                const ctx = textCanvas.getContext('2d');
                
                // Draw background (transparent)
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, 1024, 256);
                
                // Draw text with dark shadow for better daylight visibility
                ctx.font = 'bold 100px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Shadow for daylight visibility
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Calculate a more vibrant color for daylight
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;
                const brighterColor = `rgb(${Math.min(255, r * 1.2)}, ${Math.min(255, g * 1.2)}, ${Math.min(255, b * 1.2)})`;
                
                // Text color (brighter for daylight)
                ctx.fillStyle = brighterColor;
                ctx.fillText(title.toUpperCase(), 512, 128);
                
                // Create texture
                const textTexture = new THREE.CanvasTexture(textCanvas);
                
                // Use shader for high quality, simple material for low
                let textMaterial;
                
                if (qualitySettings.quality === 'low') {
                    textMaterial = createMaterial('basic', {
                        map: textTexture,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                } else {
                    textMaterial = createShaderMaterial({
                        map: { value: textTexture },
                        time: { value: 0 },
                        color: { value: new THREE.Color(color) }
                    },
                    // Vertex shader
                    `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    // Fragment shader (brightened for daylight)
                    `
                        uniform sampler2D map;
                        uniform float time;
                        uniform vec3 color;
                        varying vec2 vUv;
                        
                        void main() {
                            vec4 texColor = texture2D(map, vUv);
                            
                            // Add scan line effect (subtle for daylight)
                            float scanline = step(0.99, fract(vUv.y * 100.0 - time * 2.0)) * 0.3;
                            
                            // Add subtle glitch effect
                            float glitchIntensity = step(0.98, sin(time * 20.0 + vUv.y * 50.0)) * 0.2;
                            float glitchLine = step(0.5, fract(vUv.y * 100.0));
                            float glitch = glitchIntensity * glitchLine;
                            
                            // Distortion
                            vec2 distortion = vec2(
                                sin(vUv.y * 20.0 + time) * 0.003,
                                0.0
                            ) * glitchIntensity;
                            
                            vec4 distortedColor = texture2D(map, vUv + distortion);
                            
                            // Combine effects - brighter for daylight
                            vec3 finalColor = mix(color * 1.2, vec3(1.0), scanline + glitch);
                            
                            float alpha = distortedColor.a * (0.8 + 0.2 * sin(time * 5.0));
                            alpha = mix(alpha, 1.0, scanline);
                            
                            gl_FragColor = vec4(finalColor, alpha * texColor.a * 0.9);
                        }
                    `,
                    {
                        transparent: true,
                        blending: THREE.NormalBlending, // Changed to normal for better visibility
                        side: THREE.DoubleSide
                    });
                }
                
                const textGeometry = getBuildingGeometry('plane', {
                    width: 10, 
                    height: 2.5
                });
                
                const text = new THREE.Mesh(textGeometry, textMaterial);
                text.position.y = 5;
                text.rotation.x = -Math.PI / 8;
                group.add(text);
                
                // Store for shader updates if using shader material
                if (qualitySettings.quality !== 'low') {
                    neonSigns.push(text);
                }
                
                // Add holographic beam for higher effects quality (more visible in daylight)
                if (qualitySettings.effectsLevel !== 'minimal') {
                    const beamSegments = qualitySettings.quality === 'high' ? 16 : 8;
                    
                    const beamGeometry = getBuildingGeometry('cylinder', {
                        radiusTop: 0.2, 
                        radiusBottom: 2, 
                        height: 10,
                        radialSegments: beamSegments,
                        heightSegments: 1,
                        openEnded: true
                    });
                    
                    const beamMaterial = createShaderMaterial({
                        time: { value: 0 },
                        color: { value: new THREE.Color(color) }
                    },
                    // Vertex shader
                    `
                        uniform float time;
                        varying vec2 vUv;
                        
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    // Fragment shader (brightened and slightly less transparent for daylight)
                    `
                        uniform float time;
                        uniform vec3 color;
                        varying vec2 vUv;
                        
                        void main() {
                            // Create flowing beam effect
                            float flow = fract(vUv.y * 5.0 - time * 2.0);
                            flow = pow(flow, 3.0) * (1.0 - flow) * 3.0;
                            
                            // Add some noise
                            float noise = 0.9 + 0.1 * sin(vUv.x * 30.0 + time * 5.0);
                            
                            // Calculate alpha - increased for daylight
                            float alpha = (1.0 - vUv.y) * 0.4 * noise;
                            alpha = mix(alpha, alpha * 2.0, flow);
                            
                            gl_FragColor = vec4(color * 1.2, alpha);
                        }
                    `,
                    {
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    beam.position.y = 5;
                    group.add(beam);
                    
                    // Store for shader updates
                    neonSigns.push(beam);
                }
                
                return group;
            }
        }
        
        function createDaylightLighting() {
            // Base ambient light with balanced values
            const ambientLight = new THREE.AmbientLight(0xCCDDFF, 0.5); // Reduced intensity
            scene.add(ambientLight);
            
            // Main directional light for sun - warmer and more natural
            const mainLight = new THREE.DirectionalLight(0xFFFAF0, 1.0); // Softer sunlight
            mainLight.position.set(50, 100, 50);
            
            if (qualitySettings.shadowsEnabled) {
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 1;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -200;
                mainLight.shadow.camera.right = 200;
                mainLight.shadow.camera.top = 200;
                mainLight.shadow.camera.bottom = -200;
                mainLight.shadow.bias = -0.0003;
            }
            scene.add(mainLight);

            // Add subtle hemisphere light
            const hemiLight = new THREE.HemisphereLight(0x90B0E0, 0x8AAA66, 0.4); // Reduced intensity
            scene.add(hemiLight);

            // Add street lights with reduced intensity for daylight
            if (qualitySettings.quality !== 'low') {
                const streetLightCount = Math.min(10, qualitySettings.maxLights - cityLights.length);
                
                for (let i = -5; i <= 5; i += 2) {
                    if (i === 0) continue; // Skip center
                    
                    // Create street lights on both sides of the road
                    [-1, 1].forEach(side => {
                        if (cityLights.length >= qualitySettings.maxLights) return;
                        
                        const light = new THREE.PointLight(
                            0xFFEECC, // Warm light
                            0.3, // Reduced intensity for daylight
                            15, // Reduced range for daylight
                            2
                        );
                        
                        light.position.set(side * 8, 4, i * 20);
                        
                        scene.add(light);
                        cityLights.push(light);
                        
                        // Add light pole (simplified)
                        const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 4, 6);
                        const poleMaterial = createMaterial('standard', {
                            color: 0x888888,
                            metalness: 0.8,
                            roughness: 0.2
                        }, 'streetlight-pole');
                        
                        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                        pole.position.set(side * 8, 2, i * 20);
                        pole.castShadow = qualitySettings.shadowsEnabled;
                        scene.add(pole);
                        
                        // Add lamp
                        const lampGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                        const lampMaterial = createMaterial('standard', {
                            color: 0xFFEECC,
                            emissive: 0xFFEECC,
                            emissiveIntensity: 0.2, // Visible but not overpowering in daylight
                            transparent: true,
                            opacity: 0.9
                        }, 'streetlight-lamp');
                        
                        const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
                        lamp.position.copy(light.position);
                        scene.add(lamp);
                    });
                }
            }
        }
        
        function createParticleEffects() {
            // Skip particle effects for minimal quality
            if (qualitySettings.effectsLevel === 'minimal') return;
            
            // Create atmospheric particles (dust/pollen) for daylight - fewer for better visibility
            const atmosphereParticleCount = Math.min(qualitySettings.particleCount / 3, 1000);
            
            // Create geometry with attributes using BufferGeometry for better performance
            const atmosphereGeometry = new THREE.BufferGeometry();
            const atmospherePositions = new Float32Array(atmosphereParticleCount * 3);
            const atmosphereSizes = new Float32Array(atmosphereParticleCount);
            const atmosphereSpeeds = new Float32Array(atmosphereParticleCount);
            
            for (let i = 0; i < atmosphereParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 150;
                const height = Math.random() * 40;
                
                atmospherePositions[i * 3] = Math.sin(angle) * radius;
                atmospherePositions[i * 3 + 1] = height;
                atmospherePositions[i * 3 + 2] = Math.cos(angle) * radius;
                
                atmosphereSizes[i] = 0.1 + Math.random() * 0.4; // Smaller for daylight
                atmosphereSpeeds[i] = 0.1 + Math.random() * 0.4; // Slower for more realism
            }
            
            atmosphereGeometry.setAttribute('position', new THREE.BufferAttribute(atmospherePositions, 3));
            atmosphereGeometry.setAttribute('size', new THREE.BufferAttribute(atmosphereSizes, 1));
            atmosphereGeometry.setAttribute('speed', new THREE.BufferAttribute(atmosphereSpeeds, 1));
            
            // Daylight optimized shader for particles
            const atmosphereMaterial = createShaderMaterial({
                time: { value: 0 },
                fogColor: { value: new THREE.Color(0xE6F0FF) }, // Light blue for daylight fog
                fogDensity: { value: 0.0003 }
            }, 
            // Vertex Shader - optimized for daylight
            `
                uniform float time;
                
                attribute float size;
                attribute float speed;
                
                varying float vAlpha;
                varying float vSize;
                
                void main() {
                    vec3 pos = position;
                    
                    // Slow vertical movement
                    pos.y = mod(pos.y + time * speed * 0.2, 40.0);
                    
                    // Slow horizontal drift
                    pos.x += sin(time * 0.05 + position.z * 0.05) * 0.1;
                    pos.z += cos(time * 0.05 + position.x * 0.05) * 0.1;
                    
                    // Fade based on position for daylight visibility
                    float distFromCenter = length(pos.xz);
                    float heightFactor = smoothstep(0.0, 10.0, pos.y) * smoothstep(40.0, 30.0, pos.y);
                    float distFactor = smoothstep(150.0, 50.0, distFromCenter);
                    vAlpha = heightFactor * distFactor * 0.15; // Reduced for daylight
                    
                    vSize = size * (0.7 + 0.3 * sin(time * 0.3 + position.y * 0.1));
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = vSize * (20.0 / -mvPosition.z); // Smaller for better daylight visibility
                    gl_Position = projectionMatrix * mvPosition;
                }
            `, 
            // Fragment Shader - optimized for daylight
            `
                uniform vec3 fogColor;
                uniform float fogDensity;
                
                varying float vAlpha;
                varying float vSize;
                
                void main() {
                    // Create soft particle shape
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    if (dist > 0.5) discard;
                    
                    // Create soft edge
                    float alpha = smoothstep(0.5, 0.2, dist) * vAlpha;
                    
                    // Off-white particles for daylight visibility
                    vec3 color = vec3(0.9, 0.95, 1.0);
                    
                    // Apply fog
                    float depth = gl_FragCoord.z / gl_FragCoord.w;
                    float fogFactor = 1.0 - exp(-fogDensity * depth * depth);
                    color = mix(color, fogColor, fogFactor);
                    
                    gl_FragColor = vec4(color, alpha * 0.4); // Reduced alpha for daylight
                }
            `,
            {
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            const atmosphereParticles = new THREE.Points(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphereParticles);
            particleSystems.push(atmosphereParticles);
            
            // Add butterflies/insects for daylight scene
            if (qualitySettings.quality !== 'low') {
                createFlutteringInsects();
            }
            
            // Add pollen particles for ultra settings - reduced for daylight
            if (qualitySettings.effectsLevel === 'ultra') {
                const pollenCount = qualitySettings.quality === 'high' ? 500 : 250; // Reduced count
                const pollenGeometry = new THREE.BufferGeometry();
                const pollenPositions = new Float32Array(pollenCount * 3);
                const pollenSizes = new Float32Array(pollenCount);
                const pollenSpeeds = new Float32Array(pollenCount);
                
                for (let i = 0; i < pollenCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 120;
                    const height = Math.random() * 30;
                    
                    pollenPositions[i * 3] = Math.sin(angle) * radius;
                    pollenPositions[i * 3 + 1] = height;
                    pollenPositions[i * 3 + 2] = Math.cos(angle) * radius;
                    
                    pollenSizes[i] = 0.1 + Math.random() * 0.3; // Smaller particles for daylight
                    pollenSpeeds[i] = 0.03 + Math.random() * 0.1; // Slower movement
                }
                
                pollenGeometry.setAttribute('position', new THREE.BufferAttribute(pollenPositions, 3));
                pollenGeometry.setAttribute('size', new THREE.BufferAttribute(pollenSizes, 1));
                pollenGeometry.setAttribute('speed', new THREE.BufferAttribute(pollenSpeeds, 1));
                
                const pollenMaterial = createShaderMaterial({
                    time: { value: 0 }
                },
                // Vertex shader
                `
                    uniform float time;
                    attribute float size;
                    attribute float speed;
                    
                    varying float vAlpha;
                    
                    void main() {
                        vec3 pos = position;
                        
                        // Floating movement pattern
                        float t = time * speed;
                        pos.x += sin(t * 0.3) * 0.2;
                        pos.y = mod(pos.y - t * 0.1, 30.0); // Slowly falling
                        pos.z += cos(t * 0.3) * 0.2;
                        
                        // Fade based on height
                        vAlpha = 0.2 + 0.5 * smoothstep(0.0, 5.0, pos.y);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (8.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                // Fragment shader
                `
                    varying float vAlpha;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        
                        // Create soft edge with daylight-visible colors
                        float alpha = smoothstep(0.5, 0.3, dist) * vAlpha;
                        
                        // Off-white color for pollen
                        vec3 color = vec3(1.0, 0.98, 0.9);
                        
                        gl_FragColor = vec4(color, alpha * 0.3); // Very subtle in daylight
                    }
                `,
                {
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                
                const pollen = new THREE.Points(pollenGeometry, pollenMaterial);
                scene.add(pollen);
                particleSystems.push(pollen);
            }
        }
        
        function createFlutteringInsects() {
            // Add butterflies or similar small flying insects for daylight scene
            const insectCount = qualitySettings.quality === 'high' ? 20 : 10;
            
            for (let i = 0; i < insectCount; i++) {
                const insect = createInsect();
                
                // Random position within scene
                const angle = Math.random() * Math.PI * 2;
                const radius = 20 + Math.random() * 100;
                const height = 1 + Math.random() * 15;
                
                insect.position.set(
                    Math.sin(angle) * radius,
                    height,
                    Math.cos(angle) * radius
                );
                
                // Set movement parameters
                insect.userData.movement = {
                    speed: 0.05 + Math.random() * 0.1,
                    radius: 5 + Math.random() * 15,
                    centerX: insect.position.x,
                    centerZ: insect.position.z,
                    height: height,
                    verticalSpeed: 0.02 + Math.random() * 0.04,
                    verticalRange: 1 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    wingSpeed: 0.2 + Math.random() * 0.3
                };
                
                scene.add(insect);
                drones.push(insect);
            }
        }
        
        function createInsect() {
            const group = new THREE.Group();
            const detailLevel = qualitySettings.geometryDetail;
            
            // Body
            const bodyGeometry = getGeometry('cylinder', {
                radiusTop: 0.05,
                radiusBottom: 0.1,
                height: 0.4,
                radialSegments: 8
            }, detailLevel);
            
            // Randomize butterfly/insect color - brighter colors for daylight
            const colors = [
                0xFF9900, // Orange
                0xFFCC00, // Yellow
                0x66CCFF, // Light blue
                0xFFFFFF, // White
                0x88FF88  // Light green
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const bodyMaterial = createMaterial('standard', {
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            }, 'insect-body');
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = qualitySettings.shadowsEnabled;
            group.add(body);
            
            // Wings
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.quadraticCurveTo(0.15, 0.1, 0.3, 0);
            wingShape.quadraticCurveTo(0.15, -0.1, 0, 0);
            
            const wingGeometry = new THREE.ShapeGeometry(wingShape);
            const wingMaterial = createMaterial('standard', {
                color: color,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            }, `insect-wing-${color}`);
            
            // Left wing
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.05, 0, 0);
            leftWing.rotation.y = Math.PI / 2;
            leftWing.userData = {
                isWing: true,
                side: 'left'
            };
            leftWing.castShadow = qualitySettings.shadowsEnabled;
            body.add(leftWing);
            
            // Right wing
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.05, 0, 0);
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.scale.x = -1; // Mirror
            rightWing.userData = {
                isWing: true,
                side: 'right'
            };
            rightWing.castShadow = qualitySettings.shadowsEnabled;
            body.add(rightWing);
            
            return group;
        }
        
        function createBillboards() {
            // Adjust billboard count based on quality settings
            const billboardCount = qualitySettings.quality === 'low' ? 4 : 
                                  qualitySettings.quality === 'medium' ? 7 : 10;
            
            for (let i = 0; i < billboardCount; i++) {
                const angle = (i / billboardCount) * Math.PI * 2;
                const radius = 70 + Math.random() * 30;
                
                const billboard = createDaylightBillboard();
                billboard.position.set(
                    Math.sin(angle) * radius,
                    0,
                    Math.cos(angle) * radius
                );
                
                // Have billboard face center
                billboard.rotation.y = angle + Math.PI;
                
                scene.add(billboard);
                billboards.push(billboard);
            }
        }
        
        function createDaylightBillboard() {
            const group = new THREE.Group();
            const detailLevel = qualitySettings.geometryDetail;
            
            // Support structure - simple regardless of quality
            const pillarGeometry = getGeometry('cylinder', {
                radiusTop: 0.5,
                radiusBottom: 0.6,
                height: 15,
                radialSegments: 8
            }, detailLevel);
            
            const pillarMaterial = createMaterial('standard', {
                color: 0x888888,
                metalness: 0.5,
                roughness: 0.5
            }, 'billboard-pillar');
            
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 7.5;
            pillar.castShadow = qualitySettings.shadowsEnabled;
            group.add(pillar);
            
            // Billboard screen
            const screenWidth = 12;
            const screenHeight = 8;
            const screenGeometry = getGeometry('plane', {
                width: screenWidth,
                height: screenHeight
            }, detailLevel);
            
            // Create different types of billboards - higher contrast for daylight
            const billboardType = Math.floor(Math.random() * 4);
            let screenMaterial;
            
            switch(billboardType) {
                case 0: // Corporate ad
                    screenMaterial = createCorporateAdMaterial();
                    break;
                case 1: // Product ad
                    screenMaterial = createProductAdMaterial();
                    break;
                case 2: // Eco-friendly tech ad (for daylight theme)
                    screenMaterial = createEcoTechAdMaterial();
                    break;
                case 3: // News screen
                    screenMaterial = createNewsScreenMaterial();
                    break;
            }
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.y = 12;
            screen.position.z = -0.5;
            screen.castShadow = qualitySettings.shadowsEnabled;
            group.add(screen);
            
            // Add solar panel at top to power the billboard
            const panelGeometry = getGeometry('box', {
                width: screenWidth,
                height: 0.2,
                depth: 1.5
            }, detailLevel);
            
            const panelMaterial = createMaterial('standard', {
                color: 0x2244AA,
                metalness: 0.9,
                roughness: 0.1,
                envMapIntensity: 1.0
            }, 'billboard-solar');
            
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(0, 12 + screenHeight/2 + 0.5, -0.5);
            panel.rotation.x = Math.PI / 6; // Tilt toward sun
            panel.castShadow = qualitySettings.shadowsEnabled;
            group.add(panel);
            
            return group;
            
            function createCorporateAdMaterial() {
                // Create canvas for the ad - optimize for performance
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Choose random corporation
                const corps = [
                    { name: "ARASAKA", color: "#cc0000", slogan: "SECURITY THROUGH TECHNOLOGY" },
                    { name: "MILITECH", color: "#0044cc", slogan: "DEFENSE YOU CAN TRUST" },
                    { name: "BIOTECHNICA", color: "#00aa00", slogan: "DESIGNING BETTER LIFE" },
                    { name: "ZETATECH", color: "#cc6600", slogan: "INNOVATION BEYOND LIMITS" }
                ];
                
                const corp = corps[Math.floor(Math.random() * corps.length)];
                
                // Draw bright background for daylight visibility
                const gradient = ctx.createLinearGradient(0, 0, 0, 256);
                gradient.addColorStop(0, "#FFFFFF");
                gradient.addColorStop(1, "#EEEEFF");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 256);
                
                // Draw corporate logo - darker for contrast in daylight
                ctx.fillStyle = corp.color;
                ctx.font = "bold 80px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(corp.name, 256, 100);
                
                // Draw slogan - dark text for visibility
                ctx.fillStyle = "#000000";
                ctx.font = "bold 24px Arial";
                ctx.fillText(corp.slogan, 256, 180);
                
                const texture = new THREE.CanvasTexture(canvas);
                
                return createMaterial('basic', {
                    map: texture,
                    transparent: false
                });
            }
            
            function createProductAdMaterial() {
                // Optimized for performance
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Simple product ad with high contrast for daylight
                const products = [
                    { name: "NEURALINK PRO", color: "#007744", slogan: "UPGRADE YOUR MIND" },
                    { name: "CYBEREYE X1", color: "#cc0044", slogan: "SEE BEYOND REALITY" },
                    { name: "MANTIS BLADES", color: "#cc8800", slogan: "EXTEND YOUR REACH" },
                    { name: "GHOST RUNNER", color: "#0088cc", slogan: "LEAVE NO TRACE" }
                ];
                
                const product = products[Math.floor(Math.random() * products.length)];
                
                // Draw bright background for daylight visibility
                const gradient = ctx.createLinearGradient(0, 0, 512, 256);
                gradient.addColorStop(0, "#FFFFFF");
                gradient.addColorStop(1, "#F8F8F8");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 256);
                
                // Add bold border
                ctx.strokeStyle = product.color;
                ctx.lineWidth = 8;
                ctx.strokeRect(10, 10, 492, 236);
                
                // Draw product name
                ctx.fillStyle = product.color;
                ctx.font = "bold 60px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(product.name, 256, 60);
                
                // Draw slogan
                ctx.fillStyle = "#111111";
                ctx.font = "bold 24px Arial";
                ctx.fillText(product.slogan, 256, 220);
                
                // Draw price/call to action
                ctx.fillStyle = product.color;
                ctx.font = "bold 30px Arial";
                ctx.fillText("BUY NOW: ¬•" + Math.floor(Math.random() * 100000), 256, 180);
                
                // Draw simple product icon
                ctx.beginPath();
                ctx.arc(256, 130, 50, 0, Math.PI * 2);
                ctx.fillStyle = product.color;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(256, 130, 40, 0, Math.PI * 2);
                ctx.fillStyle = "#FFFFFF";
                ctx.fill();
                
                // Draw an icon in the circle based on product
                ctx.fillStyle = product.color;
                ctx.font = "bold 30px Arial";
                
                let icon = "‚öôÔ∏è";
                if (product.name.includes("EYE")) icon = "üëÅÔ∏è";
                if (product.name.includes("BLADES")) icon = "‚öîÔ∏è";
                if (product.name.includes("RUNNER")) icon = "üëü";
                
                ctx.fillText(icon, 256, 130);
                
                const texture = new THREE.CanvasTexture(canvas);
                
                return createMaterial('basic', {
                    map: texture,
                    transparent: false
                });
            }
            
            function createEcoTechAdMaterial() {
                // Create eco-friendly tech ad for daylight theme
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Choose random eco-tech company
                const ecoTechs = [
                    { name: "SOLARIS", color: "#008833", slogan: "POWERING THE FUTURE" },
                    { name: "AQUACORE", color: "#0066aa", slogan: "CLEAN WATER SOLUTIONS" },
                    { name: "TERRAFORM", color: "#448800", slogan: "REBUILDING ECOSYSTEMS" },
                    { name: "ATMOSPHERIX", color: "#008888", slogan: "BREATHING INNOVATION" }
                ];
                
                const ecoTech = ecoTechs[Math.floor(Math.random() * ecoTechs.length)];
                
                // Draw natural gradient background - light for daylight visibility
                const gradient = ctx.createLinearGradient(0, 0, 512, 256);
                gradient.addColorStop(0, "#FFFFFF");
                gradient.addColorStop(1, "#EEFFEE");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 256);
                
                // Draw company name
                ctx.fillStyle = ecoTech.color;
                ctx.font = "bold 70px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(ecoTech.name, 256, 80);
                
                // Draw slogan
                ctx.fillStyle = "#003311";
                ctx.font = "bold 24px Arial";
                ctx.fillText(ecoTech.slogan, 256, 130);
                
                // Draw eco symbol
                ctx.fillStyle = ecoTech.color;
                
                // Draw eco logo based on company name
                if (ecoTech.name === "SOLARIS") {
                    // Draw a sun
                    ctx.beginPath();
                    ctx.arc(256, 190, 35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sun rays
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(256 + Math.cos(angle) * 35, 190 + Math.sin(angle) * 35);
                        ctx.lineTo(256 + Math.cos(angle) * 50, 190 + Math.sin(angle) * 50);
                        ctx.lineWidth = 5;
                        ctx.stroke();
                    }
                } else if (ecoTech.name === "AQUACORE") {
                    // Draw a water drop
                    ctx.beginPath();
                    ctx.arc(256, 180, 30, 0, Math.PI);
                    ctx.lineTo(256, 220);
                    ctx.fill();
                    
                    // Add ripples
                    ctx.beginPath();
                    ctx.arc(256, 180, 40, Math.PI * 0.7, Math.PI * 0.3, true);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(256, 180, 50, Math.PI * 0.8, Math.PI * 0.2, true);
                    ctx.stroke();
                } else {
                    // Generic leaf logo for others
                    ctx.beginPath();
                    ctx.ellipse(256, 190, 30, 40, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = "#FFFFFF";
                    ctx.beginPath();
                    ctx.ellipse(256, 190, 15, 25, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                
                return createMaterial('basic', {
                    map: texture,
                    transparent: false
                });
            }
            
            function createNewsScreenMaterial() {
                // Optimized for performance with daylight visibility
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Generate random news headline - eco/tech focused for daylight theme
                const headlines = [
                    "SOLAR INNOVATION BREAKS EFFICIENCY RECORDS",
                    "ECO-DISTRICT EXPANSION APPROVED FOR BAY CITY",
                    "CLEAN WATER INITIATIVE REACHES MILESTONE",
                    "TECH GIANTS PLEDGE CARBON NEUTRALITY BY 2030",
                    "NEW ECO-FRIENDLY PUBLIC TRANSPORT UNVEILED"
                ];
                
                const headline = headlines[Math.floor(Math.random() * headlines.length)];
                
                // Draw bright background for daylight visibility
                ctx.fillStyle = "#FFFFFF";
                ctx.fillRect(0, 0, 512, 256);
                
                // Draw news network logo
                const networks = [
                    { name: "N54 NEWS", color: "#0044cc" },
                    { name: "BAY CITY NEWS", color: "#cc0000" },
                    { name: "ECO NETWORK", color: "#008800" }
                ];
                
                const network = networks[Math.floor(Math.random() * networks.length)];
                
                // Draw header bar
                ctx.fillStyle = network.color;
                ctx.fillRect(0, 0, 512, 50);
                
                // Draw network name
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "bold 30px Arial";
                ctx.textBaseline = "middle";
                ctx.textAlign = "left";
                ctx.fillText(network.name, 20, 25);
                
                // Draw red LIVE indicator
                ctx.fillStyle = "#ff0000";
                ctx.font = "bold 20px Arial";
                ctx.textAlign = "right";
                ctx.fillText("LIVE", 492, 25);
                
                // Draw headline - dark text for contrast
                ctx.fillStyle = "#000000";
                ctx.font = "bold 28px Arial";
                ctx.textAlign = "center";
                ctx.fillText(headline, 256, 100, 490); // With max width
                
                // If headline is too long, split to second line
                if (ctx.measureText(headline).width > 490) {
                    const words = headline.split(' ');
                    let line1 = '';
                    let line2 = '';
                    
                    let i;
                    for (i = 0; i < words.length; i++) {
                        const testLine = line1 + words[i] + ' ';
                        if (ctx.measureText(testLine).width < 490) {
                            line1 = testLine;
                        } else {
                            break;
                        }
                    }
                    
                    for (; i < words.length; i++) {
                        line2 += words[i] + ' ';
                    }
                    
                    ctx.fillText(line1, 256, 90);
                    ctx.fillText(line2, 256, 125);
                }
                
                // Draw time and date
                const now = new Date();
                ctx.fillStyle = "#555555";
                ctx.font = "16px Arial";
                ctx.textAlign = "right";
                ctx.fillText(now.toLocaleTimeString() + " ‚Ä¢ " + now.toLocaleDateString(), 492, 60);
                
                // Draw news ticker
                ctx.fillStyle = network.color;
                ctx.fillRect(0, 200, 512, 40);
                
                // Draw ticker text background (white for better visibility)
                ctx.fillStyle = "#FFFFFF";
                ctx.fillRect(3, 203, 506, 34);
                
                // Draw ticker text (dark for contrast)
                ctx.fillStyle = "#000000";
                ctx.font = "18px Arial";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                ctx.fillText("MARKETS UP 3% ‚Ä¢ RENEWABLE ENERGY ADOPTION INCREASES ‚Ä¢ WEATHER: SUNNY", 10, 220);
                
                const texture = new THREE.CanvasTexture(canvas);
                
                return createMaterial('basic', {
                    map: texture,
                    transparent: false
                });
            }
        }
        
        function createDrones() {
            // Skip drones for low effects quality
            if (qualitySettings.effectsLevel === 'minimal') return;
            
            // Adjust drone count based on quality settings
            const droneCount = qualitySettings.quality === 'low' ? 5 : 
                             qualitySettings.quality === 'medium' ? 8 : 12;
            
            for (let i = 0; i < droneCount; i++) {
                const drone = createDaylightDrone();
                const radius = 30 + Math.random() * 80;
                const angle = Math.random() * Math.PI * 2;
                const height = 10 + Math.random() * 30;
                
                drone.position.set(
                    Math.sin(angle) * radius,
                    height,
                    Math.cos(angle) * radius
                );
                
                // Set movement parameters
                drone.userData.movement = {
                    radius: radius,
                    angle: angle,
                    height: height,
                    speed: 0.001 + Math.random() * 0.003,
                    wobble: Math.random() * 0.01,
                    wobbleSpeed: 0.5 + Math.random() * 2
                };
                
                scene.add(drone);
                drones.push(drone);
            }
        }
        
        function createDaylightDrone() {
            const group = new THREE.Group();
            
            // Choose drone types optimized for daylight
            const droneType = Math.floor(Math.random() * 3);
            
            switch (droneType) {
                case 0:
                    createDeliveryDrone(group);
                    break;
                case 1:
                    createSurveyDrone(group);
                    break;
                case 2:
                    createEcoMonitoringDrone(group);
                    break;
            }
            
            return group;
        }
        
        function createDeliveryDrone(group) {
            const detailLevel = qualitySettings.geometryDetail;
            
            // Body - lighter color for better visibility in daylight
            const bodyGeometry = getGeometry('box', {
                width: 2, 
                height: 0.6, 
                depth: 2
            }, detailLevel);
            
            const bodyMaterial = createMaterial('standard', {
                color: 0xE0E0E0, // Lighter grey for visibility
                metalness: 0.4,
                roughness: 0.6
            }, 'drone-body-white');
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = qualitySettings.shadowsEnabled;
            group.add(body);
            
            // Package
            const packageGeometry = getGeometry('box', {
                width: 1, 
                height: 0.7, 
                depth: 1
            }, detailLevel);
            
            const packageMaterial = createMaterial('standard', {
                color: 0xBB7744, // Cardboard brown color
                metalness: 0.1,
                roughness: 0.9
            }, 'drone-package');
            
            const packageMesh = new THREE.Mesh(packageGeometry, packageMaterial);
            packageMesh.position.y = -0.65;
            packageMesh.castShadow = qualitySettings.shadowsEnabled;
            group.add(packageMesh);
            
            // Add company logo
            const logoGeometry = getGeometry('plane', {
                width: 1.2, 
                height: 0.5
            }, detailLevel);
            
            // Create a canvas for the logo texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw logo background
            ctx.fillStyle = '#0055AA';
            ctx.fillRect(0, 0, 256, 128);
            
            // Draw logo text
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('AERO', 128, 64);
            
            const logoTexture = new THREE.CanvasTexture(canvas);
            const logoMaterial = createMaterial('basic', {
                map: logoTexture
            });
            
            const logo = new THREE.Mesh(logoGeometry, logoMaterial);
            logo.position.set(0, 0.31, 0);
            logo.rotation.x = -Math.PI / 2;
            group.add(logo);
            
            // Add arms and rotors
            const armPositions = [
                { x: 1, z: 1 },
                { x: 1, z: -1 },
                { x: -1, z: 1 },
                { x: -1, z: -1 }
            ];
            
            const armGeometry = getGeometry('cylinder', {
                radiusTop: 0.05, 
                radiusBottom: 0.05, 
                height: 1.2,
                radialSegments: 8
            }, detailLevel);
            
            const armMaterial = createMaterial('standard', {
                color: 0x555555,
                metalness: 0.6,
                roughness: 0.4
            }, 'drone-arm');
            
            armPositions.forEach(pos => {
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos.x * 0.6, 0, pos.z * 0.6);
                arm.rotation.z = Math.PI / 2;
                arm.rotation.y = Math.atan2(pos.x, pos.z);
                arm.castShadow = qualitySettings.shadowsEnabled;
                group.add(arm);
                
                // Add motor housing
                const motorGeometry = getGeometry('cylinder', {
                    radiusTop: 0.15, 
                    radiusBottom: 0.15, 
                    height: 0.2,
                    radialSegments: 8
                }, detailLevel);
                
                const motor = new THREE.Mesh(motorGeometry, bodyMaterial);
                motor.position.set(pos.x * 1.1, 0, pos.z * 1.1);
                motor.castShadow = qualitySettings.shadowsEnabled;
                group.add(motor);
                
                // Add rotor
                const rotorGeometry = getGeometry('cylinder', {
                    radiusTop: 0.01, 
                    radiusBottom: 0.01, 
                    height: 1.5,
                    radialSegments: 6
                }, detailLevel);
                
                const rotorMaterial = createMaterial('standard', {
                    color: 0x333333,
                    metalness: 0.4,
                    roughness: 0.8,
                    transparent: true,
                    opacity: 0.7
                }, 'drone-rotor');
                
                const rotorGroup = new THREE.Group();
                
                for (let i = 0; i < 2; i++) {
                    const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                    rotor.rotation.z = i * Math.PI / 2;
                    rotorGroup.add(rotor);
                }
                
                rotorGroup.position.set(pos.x * 1.1, 0.1, pos.z * 1.1);
                rotorGroup.userData = { 
                    rotationSpeed: (Math.random() > 0.5 ? 1 : -1) * (0.2 + Math.random() * 0.2) 
                };
                group.add(rotorGroup);
            });
            
            // Add navigation lights for better visibility
            [-1, 1].forEach((side, i) => {
                const lightGeometry = getGeometry('sphere', {
                    radius: 0.08, 
                    widthSegments: 8, 
                    heightSegments: 8
                }, detailLevel);
                
                // Green right, red left (aviation standard)
                const color = side > 0 ? 0x00CC00 : 0xCC0000;
                
                const lightMaterial = createMaterial('standard', {
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5, // Brighter for daylight
                    transparent: true,
                    opacity: 0.9
                }, `drone-light-${color}`);
                
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.set(side * 1.1, 0, 0);
                light.castShadow = qualitySettings.shadowsEnabled;
                light.userData = { pulseSpeed: 2 + Math.random() * 2 };
                group.add(light);
            });
            
            return group;
        }
        
        function createSurveyDrone(group) {
            const detailLevel = qualitySettings.geometryDetail;
            
            // Body - distinctive color for survey drone
            const bodyGeometry = getGeometry('cylinder', {
                radiusTop: 0.8,
                radiusBottom: 0.8,
                height: 0.4,
                radialSegments: 6
            }, detailLevel);
            
            const bodyMaterial = createMaterial('standard', {
                color: 0x4477FF, // Bright blue for visibility
                metalness: 0.7,
                roughness: 0.3
            }, 'survey-drone-body');
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = qualitySettings.shadowsEnabled;
            group.add(body);
            
            // Camera gimbal
            const gimbalGeometry = getGeometry('sphere', {
                radius: 0.3,
                widthSegments: 12,
                heightSegments: 12
            }, detailLevel);
            
            const gimbalMaterial = createMaterial('standard', {
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            }, 'drone-gimbal');
            
            const gimbal = new THREE.Mesh(gimbalGeometry, gimbalMaterial);
            gimbal.position.y = -0.3;
            gimbal.castShadow = qualitySettings.shadowsEnabled;
            group.add(gimbal);
            
            // Camera lens
            const lensGeometry = getGeometry('cylinder', {
                radiusTop: 0.1,
                radiusBottom: 0.15,
                height: 0.2,
                radialSegments: 12
            }, detailLevel);
            
            const lensMaterial = createMaterial('standard', {
                color: 0x111111,
                metalness: 0.9,
                roughness: 0.1
            }, 'drone-lens');
            
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.position.set(0, -0.5, 0);
            lens.rotation.x = Math.PI / 2;
            lens.castShadow = qualitySettings.shadowsEnabled;
            group.add(lens);
            
            // Add solar panel on top - key feature for daylight drones
            const solarPanelGeometry = getGeometry('cylinder', {
                radiusTop: 0.8,
                radiusBottom: 0.8,
                height: 0.05,
                radialSegments: 16
            }, detailLevel);
            
            const solarPanelMaterial = createMaterial('physical', {
                color: 0x2244AA,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            }, 'drone-solar-panel');
            
            const solarPanel = new THREE.Mesh(solarPanelGeometry, solarPanelMaterial);
            solarPanel.position.y = 0.225;
            group.add(solarPanel);
            
            // Add grid pattern to solar panel
            const gridGeometry = getGeometry('plane', {
                width: 1.4,
                height: 1.4
            }, detailLevel);
            
            // Create a grid texture
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw dark blue background
            ctx.fillStyle = '#1a3366';
            ctx.fillRect(0, 0, 128, 128);
            
            // Draw grid lines
            ctx.strokeStyle = '#3366cc';
            ctx.lineWidth = 1;
            
            // Vertical and horizontal lines
            for (let i = 8; i < 128; i += 8) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 128);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(128, i);
                ctx.stroke();
            }
            
            const gridTexture = new THREE.CanvasTexture(canvas);
            const gridMaterial = createMaterial('basic', {
                map: gridTexture,
                transparent: true,
                opacity: 0.8
            });
            
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = 0.03;
            solarPanel.add(grid);
            
            // Add propeller arms and propellers
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                
                const armGeometry = getGeometry('box', {
                    width: 0.1,
                    height: 0.1,
                    depth: 0.8
                }, detailLevel);
                
                const armMaterial = createMaterial('standard', {
                    color: 0x666666,
                    metalness: 0.6,
                    roughness: 0.4
                }, 'survey-drone-arm');
                
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(
                    Math.sin(angle) * 0.4,
                    0,
                    Math.cos(angle) * 0.4
                );
                arm.rotation.y = angle;
                arm.castShadow = qualitySettings.shadowsEnabled;
                group.add(arm);
                
                // Add motor housing at end of arm
                const motorGeometry = getGeometry('cylinder', {
                    radiusTop: 0.1,
                    radiusBottom: 0.1,
                    height: 0.15,
                    radialSegments: 8
                }, detailLevel);
                
                const motorPos = new THREE.Vector3(
                    Math.sin(angle) * 0.8,
                    0,
                    Math.cos(angle) * 0.8
                );
                
                const motor = new THREE.Mesh(motorGeometry, bodyMaterial);
                motor.position.copy(motorPos);
                motor.castShadow = qualitySettings.shadowsEnabled;
                group.add(motor);
                
                // Add propeller at motor position
                const propellerGeometry = getGeometry('box', {
                    width: 0.04,
                    height: 0.02,
                    depth: 0.6
                }, detailLevel);
                
                const propellerMaterial = createMaterial('standard', {
                    color: 0x222222,
                    metalness: 0.3,
                    roughness: 0.8,
                    transparent: true,
                    opacity: 0.8
                }, 'drone-propeller');
                
                const propellerGroup = new THREE.Group();
                
                // Create triple propeller
                for (let j = 0; j < 3; j++) {
                    const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                    propeller.rotation.y = j * Math.PI / 1.5;
                    propellerGroup.add(propeller);
                }
                
                propellerGroup.position.set(motorPos.x, motorPos.y + 0.075, motorPos.z);
                propellerGroup.userData = { 
                    rotationSpeed: (i % 2 === 0 ? 1 : -1) * (0.25 + Math.random() * 0.2)
                };
                group.add(propellerGroup);
            }
            
            return group;
        }
        
        function createEcoMonitoringDrone(group) {
            const detailLevel = qualitySettings.geometryDetail;
            
            // Body - green design for eco-theme
            const bodyGeometry = getGeometry('cylinder', {
                radiusTop: 0.6,
                radiusBottom: 0.8,
                height: 0.5,
                radialSegments: 8
            }, detailLevel);
            
            const bodyMaterial = createMaterial('standard', {
                color: 0x44AA44, // Green for eco theme
                metalness: 0.4,
                roughness: 0.6
            }, 'eco-drone-body');
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = qualitySettings.shadowsEnabled;
            group.add(body);
            
            // Top cover with solar panel
            const topGeometry = getGeometry('cylinder', {
                radiusTop: 0.5,
                radiusBottom: 0.6,
                height: 0.1,
                radialSegments: 8
            }, detailLevel);
            
            const topMaterial = createMaterial('standard', {
                color: 0x2244AA,
                metalness: 0.9,
                roughness: 0.1,
                envMapIntensity: 1.0
            }, 'drone-solar-panel');
            
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 0.3;
            top.castShadow = qualitySettings.shadowsEnabled;
            group.add(top);
            
            // Solar panel grid texture
            const gridGeometry = getGeometry('plane', {
                width: 0.9,
                height: 0.9
            }, detailLevel);
            
            // Create a canvas for the grid texture
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw grid
            ctx.fillStyle = '#1a3366';
            ctx.fillRect(0, 0, 128, 128);
            
            ctx.strokeStyle = '#3366cc';
            ctx.lineWidth = 1;
            
            // Create grid lines
            for (let i = 8; i < 128; i += 8) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 128);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(128, i);
                ctx.stroke();
            }
            
            const gridTexture = new THREE.CanvasTexture(canvas);
            const gridMaterial = createMaterial('basic', {
                map: gridTexture,
                transparent: true,
                opacity: 0.9
            });
            
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = 0.36;
            group.add(grid);
            
            // Sensor array at bottom
            const sensorGeometry = getGeometry('box', {
                width: 0.6,
                height: 0.3,
                depth: 0.6
            }, detailLevel);
            
            const sensorMaterial = createMaterial('standard', {
                color: 0x999999,
                metalness: 0.7,
                roughness: 0.3
            }, 'eco-drone-sensor');
            
            const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
            sensor.position.y = -0.4;
            sensor.castShadow = qualitySettings.shadowsEnabled;
            group.add(sensor);
            
            // Add sensor lenses with brighter colors for daylight visibility
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                
                const lensGeometry = getGeometry('cylinder', {
                    radiusTop: 0.08,
                    radiusBottom: 0.1,
                    height: 0.1,
                    radialSegments: 8
                }, detailLevel);
                
                const lensMaterial = createMaterial('standard', {
                    color: 0x00AACC, // Bright blue for visibility
                    metalness: 0.8,
                    roughness: 0.1
                }, 'eco-drone-lens');
                
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                lens.position.set(
                    Math.sin(angle) * 0.25,
                    -0.55,
                    Math.cos(angle) * 0.25
                );
                lens.rotation.x = Math.PI / 2;
                lens.castShadow = qualitySettings.shadowsEnabled;
                group.add(lens);
            }
            
            // Add four arms with propellers
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;  // Offset for X configuration
                
                const armGeometry = getGeometry('box', {
                    width: 0.1,
                    height: 0.1,
                    depth: 0.8
                }, detailLevel);
                
                const arm = new THREE.Mesh(armGeometry, bodyMaterial);
                arm.position.set(
                    Math.sin(angle) * 0.4,
                    0,
                    Math.cos(angle) * 0.4
                );
                arm.rotation.y = angle;
                arm.castShadow = qualitySettings.shadowsEnabled;
                group.add(arm);
                
                // Motor at end of arm
                const motorGeometry = getGeometry('cylinder', {
                    radiusTop: 0.1,
                    radiusBottom: 0.12,
                    height: 0.15,
                    radialSegments: 8
                }, detailLevel);
                
                const motorPos = new THREE.Vector3(
                    Math.sin(angle) * 0.8,
                    0,
                    Math.cos(angle) * 0.8
                );
                
                const motor = new THREE.Mesh(motorGeometry, sensorMaterial);
                motor.position.copy(motorPos);
                motor.castShadow = qualitySettings.shadowsEnabled;
                group.add(motor);
                
                // Propeller guard
                const guardGeometry = getGeometry('torus', {
                    radius: 0.3,
                    tube: 0.03,
                    radialSegments: 8,
                    tubularSegments: 24
                }, detailLevel);
                
                const guardMaterial = createMaterial('standard', {
                    color: 0x44AA44,
                    metalness: 0.4,
                    roughness: 0.6
                }, 'eco-drone-guard');
                
                const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                guard.position.set(motorPos.x, motorPos.y + 0.075, motorPos.z);
                guard.rotation.x = Math.PI / 2;
                guard.castShadow = qualitySettings.shadowsEnabled;
                group.add(guard);
                
                // Propeller
                const propellerGeometry = getGeometry('box', {
                    width: 0.05,
                    height: 0.02,
                    depth: 0.5
                }, detailLevel);
                
                const propellerMaterial = createMaterial('standard', {
                    color: 0x222222,
                    metalness: 0.3,
                    roughness: 0.7,
                    transparent: true,
                    opacity: 0.8
                }, 'eco-drone-propeller');
                
                const propellerGroup = new THREE.Group();
                
                // Create double propeller
                for (let j = 0; j < 2; j++) {
                    const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                    propeller.rotation.y = j * Math.PI / 2;
                    propellerGroup.add(propeller);
                }
                
                propellerGroup.position.set(motorPos.x, motorPos.y + 0.075, motorPos.z);
                propellerGroup.userData = { 
                    rotationSpeed: (i % 2 === 0 ? 1 : -1) * (0.25 + Math.random() * 0.15)
                };
                group.add(propellerGroup);
            }
            
            return group;
        }
        
        function createHolographicEffects() {
            // Skip for lower quality settings
            if (qualitySettings.effectsLevel !== 'ultra') return;
            
            // Create holographic grid on ground with optimized complexity - more transparent for daylight
            const gridSize = 200;
            const gridSegments = qualitySettings.quality === 'high' ? 50 : 30;
            
            const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridSegments, gridSegments);
            gridGeometry.rotateX(-Math.PI / 2);
            
            const gridMaterial = createShaderMaterial({
                time: { value: 0 }
            },
            // Vertex shader 
            `
                uniform float time;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    
                    // Add subtle wave animation
                    vec3 pos = position;
                    float wave = sin(position.x * 0.1 + time) * sin(position.z * 0.1 + time * 0.7) * 0.5;
                    pos.y += wave * 0.2;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            // Fragment shader (optimized for daylight visibility)
            `
                uniform float time;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    // Create simplified grid lines
                    vec2 grid = abs(fract(vUv * 40.0 - 0.5) - 0.5) / fwidth(vUv * 40.0);
                    float line = min(grid.x, grid.y);
                    
                    // Calculate distance from center for radial effect
                    float dist = length(vPosition.xz) * 0.03;
                    
                    // Pulse effect
                    float pulse = 0.5 + 0.5 * sin(time - dist);
                    
                    // Create color gradient - darker blue for better visibility in daylight
                    vec3 baseColor = mix(
                        vec3(0.0, 0.2, 0.6), // Darker blue
                        vec3(0.0, 0.4, 0.8), // Medium blue
                        pulse
                    );
                    
                    // Add grid effect
                    float gridFactor = 1.0 - min(line, 1.0);
                    gridFactor *= 0.2 + 0.8 * pulse;
                    
                    // Add radial effect
                    float radialGlow = smoothstep(0.5, 0.0, dist);
                    
                    // Combine effects
                    vec3 finalColor = mix(
                        baseColor * 0.6, // Darker base for contrast
                        baseColor,
                        gridFactor * 0.5 + radialGlow * 0.3
                    );
                    
                    // Calculate alpha - reduced for better daylight visibility
                    float alpha = gridFactor * 0.1 * (0.5 + 0.5 * pulse);
                    
                    // Fade grid at distance
                    alpha *= smoothstep(0.9, 0.2, dist);
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `, 
            {
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.position.y = 0.05;
            scene.add(grid);
            
            // Store for shader updates
            neonSigns.push(grid);
            
            // Create info terminals for waypoints - fewer for visibility
            const terminalCount = qualitySettings.quality === 'high' ? 5 : 3;
            
            for (let i = 0; i < terminalCount; i++) {
                const angle = (i / terminalCount) * Math.PI * 2;
                const dist = 60;
                
                const terminal = createInfoTerminal();
                terminal.position.set(
                    Math.sin(angle) * dist,
                    0,
                    Math.cos(angle) * dist
                );
                
                scene.add(terminal);
                hologramProjections.push(terminal);
            }
        }

        function createInfoTerminal() {
            const group = new THREE.Group();
            
            // Base
            const baseGeometry = getGeometry('cylinder', {
                radiusTop: 2,
                radiusBottom: 2.5,
                height: 1,
                radialSegments: 16
            }, qualitySettings.geometryDetail);
            
            const baseMaterial = createMaterial('standard', {
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.2
            }, 'terminal-base');
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            base.castShadow = qualitySettings.shadowsEnabled;
            base.receiveShadow = qualitySettings.shadowsEnabled;
            group.add(base);
            
            // Terminal screen
            const screenGeometry = getGeometry('plane', {
                width: 5,
                height: 7
            }, qualitySettings.geometryDetail);
            
            // Create screen texture for info terminal
            const screenCanvas = document.createElement('canvas');
            screenCanvas.width = 512;
            screenCanvas.height = 512;
            const ctx = screenCanvas.getContext('2d');
            
            // Draw terminal interface - bright white background for daylight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(0, 0, 512, 512);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(0, 80, 160, 0.4)';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= 512; x += 32) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 512);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= 512; y += 32) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            }
            
            // Draw info elements with dark text for contrast
            ctx.font = '16px monospace';
            ctx.fillStyle = 'rgba(0, 50, 120, 1)';
            
            // Header
            ctx.fillStyle = 'rgba(0, 80, 160, 1)';
            ctx.font = 'bold 24px monospace';
            ctx.fillText('CITY INFORMATION TERMINAL', 60, 40);
            
            // Content
            ctx.font = '16px monospace';
            ctx.fillStyle = 'rgba(0, 50, 120, 1)';
            
            const infoLines = [
                'WELCOME TO BAY CITY',
                'CURRENT TEMPERATURE: 72¬∞F / 22¬∞C',
                'AIR QUALITY: GOOD (AQI 35)',
                'LOCAL TIME: ' + new Date().toLocaleTimeString(),
                'SOLAR POWER PRODUCTION: 85% CAPACITY',
                'PUBLIC TRANSPORT STATUS: ON TIME',
                'ECO-SCORE: 87/100',
                '',
                'UPCOMING EVENTS:',
                '- TECH SUMMIT (CENTRAL PLAZA)',
                '- FARMERS MARKET (EAST DISTRICT)',
                '- ART EXHIBITION (GALLERY SECTOR)'
            ];
            
            infoLines.forEach((line, i) => {
                ctx.fillText(line, 40, 100 + i * 30);
            });
            
            // Draw map section with light blue background
            ctx.fillStyle = 'rgba(220, 240, 255, 1)';
            ctx.fillRect(40, 300, 432, 172);
            
            ctx.fillStyle = 'rgba(0, 80, 160, 1)';
            ctx.font = 'bold 18px monospace';
            ctx.fillText('CITY MAP', 40, 295);
            
            // Draw simplified map
            ctx.strokeStyle = 'rgba(0, 80, 160, 0.8)';
            ctx.lineWidth = 3;
            
            // Roads
            ctx.beginPath();
            ctx.moveTo(40, 386);
            ctx.lineTo(472, 386);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(256, 300);
            ctx.lineTo(256, 472);
            ctx.stroke();
            
            // Districts
            ctx.fillStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.fillRect(60, 310, 186, 66);
            ctx.fillRect(266, 310, 186, 66);
            ctx.fillRect(60, 400, 186, 66);
            ctx.fillRect(266, 400, 186, 66);
            
            ctx.fillStyle = 'rgba(0, 70, 140, 1)';
            ctx.font = '14px monospace';
            ctx.fillText('NORTH DISTRICT', 100, 345);
            ctx.fillText('EAST DISTRICT', 305, 345);
            ctx.fillText('WEST DISTRICT', 100, 435);
            ctx.fillText('SOUTH DISTRICT', 305, 435);
            
            // You are here marker
            ctx.fillStyle = 'rgba(220, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(256, 386, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.font = 'bold 12px monospace';
            ctx.fillText('YOU ARE HERE', 210, 370);
            
            const screenTexture = new THREE.CanvasTexture(screenCanvas);
            
            const screenMaterial = createMaterial('standard', {
                map: screenTexture,
                metalness: 0.2,
                roughness: 0.5
            });
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.y = 5;
            screen.castShadow = qualitySettings.shadowsEnabled;
            group.add(screen);
            
            // Add terminal post
            const postGeometry = getGeometry('cylinder', {
                radiusTop: 0.2,
                radiusBottom: 0.3,
                height: 4,
                radialSegments: 8
            }, qualitySettings.geometryDetail);
            
            const post = new THREE.Mesh(postGeometry, baseMaterial);
            post.position.y = 2;
            post.castShadow = qualitySettings.shadowsEnabled;
            group.add(post);
            
            return group;
        }
        
        function createPowerGrid() {
            // Skip for low effects quality
            if (qualitySettings.effectsLevel !== 'ultra') return;
            
            // Create power lines connecting buildings - fewer for daylight
            const powerLineCount = 16; 
            
            for (let i = 0; i < powerLineCount; i++) {
                // Choose two random buildings to connect
                const buildingIndices = [];
                while (buildingIndices.length < 2) {
                    const idx = Math.floor(Math.random() * buildings.length);
                    if (!buildingIndices.includes(idx)) {
                        buildingIndices.push(idx);
                    }
                }
                
                const building1 = buildings[buildingIndices[0]];
                const building2 = buildings[buildingIndices[1]];
                
                // Check if buildings are close enough
                const distance = building1.position.distanceTo(building2.position);
                if (distance > 120) continue;
                
                // Create power line
                const powerLine = createPowerLine(building1, building2);
                scene.add(powerLine);
                powerLines.push(powerLine);
            }
            
            function createPowerLine(building1, building2) {
                // Create curve between buildings
                const points = [];
                const start = new THREE.Vector3(
                    building1.position.x,
                    15 + Math.random() * 10,
                    building1.position.z
                );
                
                const end = new THREE.Vector3(
                    building2.position.x,
                    15 + Math.random() * 10,
                    building2.position.z
                );
                
                points.push(start);
                
                // Add middle control point with some sag
                const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                mid.y -= 5 + Math.random() * 5; // Add sag
                points.push(mid);
                
                points.push(end);
                
                const curve = new THREE.CatmullRomCurve3(points);
                
                // Adjust curve detail based on quality setting
                const curveSegments = qualitySettings.quality === 'high' ? 20 : 10;
                
                const geometry = new THREE.TubeGeometry(
                    curve, 
                    curveSegments, 
                    0.15, 
                    8, 
                    false
                );
                
                // Use standard material for daylight visibility
                const material = createMaterial('standard', {
                    color: 0x444444,
                    metalness: 0.8,
                    roughness: 0.2
                }, 'powerline');
                
                return new THREE.Mesh(geometry, material);
            }
        }
        
        function createCyberpunkDetails() {
            // Skip for low quality
            if (qualitySettings.effectsLevel !== 'ultra') return;
            
            if (qualitySettings.quality === 'high') {
                createStreetSigns();
                createInfoKiosks();
            }
        }
        
        function createStreetSigns() {
            // Create street name signs
            const streetSigns = [
                { position: { x: 15, z: -20 }, name: "SILICON AVENUE" },
                { position: { x: 15, z: 20 }, name: "NEURAL BOULEVARD" },
                { position: { x: -15, z: -40 }, name: "ECO DRIVE" },
                { position: { x: -15, z: 40 }, name: "SOLAR STREET" }
            ];
            
            const detailLevel = qualitySettings.geometryDetail;
            
            streetSigns.forEach(sign => {
                const signGroup = new THREE.Group();
                
                // Sign post
                const postGeometry = getGeometry('cylinder', {
                    radiusTop: 0.1, 
                    radiusBottom: 0.1, 
                    height: 3, 
                    radialSegments: 8
                }, detailLevel);
                
                const postMaterial = createMaterial('standard', {
                    color: 0x888888,
                    metalness: 0.6,
                    roughness: 0.4
                }, 'streetsign-post');
                
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.y = 1.5;
                post.castShadow = qualitySettings.shadowsEnabled;
                post.receiveShadow = qualitySettings.shadowsEnabled;
                signGroup.add(post);
                
                // Sign panel
                const signGeometry = getGeometry('plane', {
                    width: 4, 
                    height: 0.8
                }, detailLevel);
                
                // Create sign texture
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 512;
                signCanvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Draw sign background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, 512, 128);
                
                // Draw border
                ctx.strokeStyle = '#006644';
                ctx.lineWidth = 6;
                ctx.strokeRect(3, 3, 506, 122);
                
                // Draw text
                ctx.fillStyle = '#006644';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(sign.name, 256, 64);
                
                const signTexture = new THREE.CanvasTexture(signCanvas);
                const signMaterial = createMaterial('standard', {
                    map: signTexture,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                const signPanel = new THREE.Mesh(signGeometry, signMaterial);
                signPanel.position.set(0, 3, 0);
                signPanel.rotation.y = Math.atan2(sign.position.z, sign.position.x) + Math.PI / 2;
                signPanel.castShadow = qualitySettings.shadowsEnabled;
                signPanel.receiveShadow = qualitySettings.shadowsEnabled;
                signGroup.add(signPanel);
                
                // Position sign
                signGroup.position.set(sign.position.x, 0, sign.position.z);
                scene.add(signGroup);
            });
        }
        
        function createInfoKiosks() {
            // Create information kiosks around the map
            const kioskPositions = [
                { x: 30, z: 0 },
                { x: -30, z: 0 },
                { x: 0, z: 30 },
                { x: 0, z: -30 }
            ];
            
            kioskPositions.forEach(pos => {
                const kiosk = createInfoKiosk();
                kiosk.position.set(pos.x, 0, pos.z);
                kiosk.rotation.y = Math.atan2(-pos.x, -pos.z); // Face toward center
                scene.add(kiosk);
            });
        }
        
        function createInfoKiosk() {
            const group = new THREE.Group();
            const detailLevel = qualitySettings.geometryDetail;
            
            // Base
            const baseGeometry = getGeometry('cylinder', {
                radiusTop: 0.8,
                radiusBottom: 1.0,
                height: 0.5,
                radialSegments: 8
            }, detailLevel);
            
            const baseMaterial = createMaterial('standard', {
                color: 0x888888,
                metalness: 0.7,
                roughness: 0.3
            }, 'kiosk-base');
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            base.castShadow = qualitySettings.shadowsEnabled;
            base.receiveShadow = qualitySettings.shadowsEnabled;
            group.add(base);
            
            // Post
            const postGeometry = getGeometry('cylinder', {
                radiusTop: 0.15,
                radiusBottom: 0.2,
                height: 2.5,
                radialSegments: 8
            }, detailLevel);
            
            const post = new THREE.Mesh(postGeometry, baseMaterial);
            post.position.y = 1.5;
            post.castShadow = qualitySettings.shadowsEnabled;
            post.receiveShadow = qualitySettings.shadowsEnabled;
            group.add(post);
            
            // Screen
            const screenGeometry = getGeometry('box', {
                width: 2,
                height: 1.5,
                depth: 0.1
            }, detailLevel);
            
            const screenFrameMaterial = createMaterial('standard', {
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.2
            }, 'kiosk-frame');
            
            const screen = new THREE.Mesh(screenGeometry, screenFrameMaterial);
            screen.position.y = 3;
            screen.rotation.x = -Math.PI / 12; // Slight tilt for better viewing
            screen.castShadow = qualitySettings.shadowsEnabled;
            screen.receiveShadow = qualitySettings.shadowsEnabled;
            group.add(screen);
            
            // Screen display
            const displayGeometry = getGeometry('plane', {
                width: 1.9,
                height: 1.4
            }, detailLevel);
            
            // Create screen content
            const displayCanvas = document.createElement('canvas');
            displayCanvas.width = 512;
            displayCanvas.height = 384;
            const ctx = displayCanvas.getContext('2d');
            
            // Draw screen content
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, 512, 384);
            
            // Header
            ctx.fillStyle = '#006644';
            ctx.fillRect(0, 0, 512, 60);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('BAY CITY INFO GUIDE', 256, 30);
            
            // Content
            ctx.fillStyle = '#006644';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('POINTS OF INTEREST:', 20, 90);
            
            ctx.fillStyle = '#444444';
            ctx.font = '20px Arial';
            
            const locations = [
                'ECO-PARK: 0.5 KM EAST',
                'SOLAR PLAZA: 1.2 KM NORTH',
                'TECH MUSEUM: 0.8 KM WEST',
                'CENTRAL HUB: 1.0 KM SOUTH',
                'TRANSIT STATION: 0.3 KM NORTH-EAST'
            ];
            
            locations.forEach((loc, i) => {
                ctx.fillText(`‚Ä¢ ${loc}`, 30, 130 + i * 30);
            });
            
            // Footer
            ctx.fillStyle = '#006644';
            ctx.fillRect(0, 324, 512, 60);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TOUCH SCREEN FOR MORE INFORMATION', 256, 354);
            
            const displayTexture = new THREE.CanvasTexture(displayCanvas);
            const displayMaterial = createMaterial('standard', {
                map: displayTexture,
                metalness: 0.1,
                roughness: 0.8
            });
            
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.z = 0.06;
            display.castShadow = false;
            display.receiveShadow = false;
            screen.add(display);
            
            // Solar panel at top
            const panelGeometry = getGeometry('box', {
                width: 1.0,
                height: 0.05,
                depth: 0.7
            }, detailLevel);
            
            const panelMaterial = createMaterial('physical', {
                color: 0x2244AA,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            }, 'kiosk-solar');
            
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.y = 3.8;
            panel.rotation.x = Math.PI / 6; // Angle toward sun
            panel.castShadow = qualitySettings.shadowsEnabled;
            panel.receiveShadow = qualitySettings.shadowsEnabled;
            group.add(panel);
            
            return group;
        }
        
        // ------------------ EVENT HANDLING & CONTROLS ------------------
        
        function initCustomCursor() {
            customCursor = document.getElementById('customCursor');
            
            // Handle cursor movement with optimized mousemove handler
            document.addEventListener('mousemove', (e) => {
                // Use requestAnimationFrame for smoother cursor movement
                requestAnimationFrame(() => {
                    customCursor.style.left = e.clientX + 'px';
                    customCursor.style.top = e.clientY + 'px';
                });
            });
            
            // Handle cursor effects on interactive elements
            document.querySelectorAll('button, a').forEach(el => {
                el.addEventListener('mouseenter', () => {
                    customCursor.style.transform = 'scale(1.5)';
                    customCursor.style.backgroundColor = 'rgba(0, 119, 85, 0.4)';
                });
                
                el.addEventListener('mouseleave', () => {
                    customCursor.style.transform = 'scale(1.0)';
                    customCursor.style.backgroundColor = 'rgba(0, 119, 85, 0.2)';
                });
            });
            
            // Hide default cursor
            document.body.style.cursor = 'none';
        }
        
        function setupEventListeners() {
            // Settings menu control
            document.getElementById('settingsBtn').addEventListener('click', () => {
                const menu = document.getElementById('settingsMenu');
                menu.style.display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
            });
            
            // Apply settings button
            document.getElementById('applySettings').addEventListener('click', applySettings);
            
            // Initialize settings menu values
            document.getElementById('qualitySelect').value = qualitySettings.quality;
            document.getElementById('effectsSelect').value = qualitySettings.effectsLevel;
            
            // Window resize handler with debounce
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Update camera
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    
                    // Update renderer and composer
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                    
                    // Update FXAA pass
                    const fxaaPass = composer.passes.find(pass => pass.material && pass.material.uniforms.resolution);
                    if (fxaaPass) {
                        fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
                        fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
                    }
                }, 200);
            });
            
            // Prevent context menu on right click for better gaming experience
            document.addEventListener('contextmenu', event => event.preventDefault());
        }
        
        function applySettings() {
            const newQuality = document.getElementById('qualitySelect').value;
            const newEffects = document.getElementById('effectsSelect').value;
            
            if (newQuality !== qualitySettings.quality || newEffects !== qualitySettings.effectsLevel) {
                // Update settings
                qualitySettings.quality = newQuality;
                qualitySettings.effectsLevel = newEffects;
                
                // Update settings based on quality level
                switch(newQuality) {
                    case 'low':
                        qualitySettings.particleCount = 500;
                        qualitySettings.shadowsEnabled = false;
                        qualitySettings.maxLights = 5;
                        qualitySettings.drawDistance = 200;
                        qualitySettings.textureSize = 'small';
                        qualitySettings.geometryDetail = 'low';
                        break;
                    case 'medium':
                        qualitySettings.particleCount = 2000;
                        qualitySettings.shadowsEnabled = !isMobile;
                        qualitySettings.maxLights = 15;
                        qualitySettings.drawDistance = 500;
                        qualitySettings.textureSize = 'medium';
                        qualitySettings.geometryDetail = 'medium';
                        break;
                    case 'high':
                        qualitySettings.particleCount = 5000;
                        qualitySettings.shadowsEnabled = true;
                        qualitySettings.maxLights = 30;
                        qualitySettings.drawDistance = 1500;
                        qualitySettings.textureSize = 'large';
                        qualitySettings.geometryDetail = 'high';
                        break;
                }
                
                // Adjust post-processing
                updatePostProcessing();
                
                // Update fog
                scene.fog.density = 0.0003; // Consistent for daylight
                
                // Update shadows
                renderer.shadowMap.enabled = qualitySettings.shadowsEnabled;
                
                // Hide settings menu
                document.getElementById('settingsMenu').style.display = 'none';
                
                // Show confirmation message
                const sectionIndicator = document.getElementById('sectionIndicator');
                sectionIndicator.innerHTML = `<span style="color: #006644;">‚óè</span> SETTINGS APPLIED: ${newQuality.toUpperCase()} QUALITY, ${newEffects.toUpperCase()} EFFECTS`;
                sectionIndicator.style.display = 'block';
                
                setTimeout(() => {
                    sectionIndicator.style.display = 'none';
                }, 3000);
            }
        }
        
        function updatePostProcessing() {
            // Update bloom pass based on quality
            if (bloomPass) {
                switch(qualitySettings.effectsLevel) {
                    case 'minimal':
                        bloomPass.strength = 0.15; // Reduced from 0.3
                        bloomPass.radius = 0.4;
                        bloomPass.threshold = 0.95; // Increased threshold
                        break;
                    case 'balanced':
                        bloomPass.strength = 0.2; // Reduced from 0.4
                        bloomPass.radius = 0.35;
                        bloomPass.threshold = 0.9; // Increased threshold
                        break;
                    case 'ultra':
                        bloomPass.strength = 0.25; // Reduced from 0.5
                        bloomPass.radius = 0.3;
                        bloomPass.threshold = 0.85; // Increased threshold
                        break;
                }
            }
        }
        
        function setupControls() {
            // Keyboard controls with event delegation for better performance
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                
                // Handle SPACE key for entering nearby section
                if (event.code === 'Space' && currentSection) {
                    showModal(currentSection.userData.title, currentSection.userData.content);
                    
                    // Trigger glitch effect
                    if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                        glitchPass.enabled = true;
                        setTimeout(() => {
                            glitchPass.enabled = false;
                        }, 1000);
                    }
                }
                
                // Toggle player mode with "E" key
                if (event.code === 'KeyE') {
                    togglePlayerMode();
                }
                
                // Toggle camera mode with "C" key
                if (event.code === 'KeyC') {
                    toggleCameraMode();
                }
                
                // Prevent default for game controls
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 
                     'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ShiftLeft', 'ShiftRight'].includes(event.code)) {
                    event.preventDefault();
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });

            // Close modal with button
            document.getElementById('closeModal').addEventListener('click', () => {
                document.getElementById('modal').style.display = 'none';
                
                // Small glitch effect on close
                if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                    glitchPass.enabled = true;
                    setTimeout(() => {
                        glitchPass.enabled = false;
                    }, 500);
                }
            });

            // Close modal with ESC
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Escape') {
                    document.getElementById('modal').style.display = 'none';
                }
            });
            
            // Mouse wheel for camera zoom
            document.addEventListener('wheel', (event) => {
                // Adjust camera distance
                cameraDistance += event.deltaY * 0.01;
                cameraDistance = Math.max(5, Math.min(cameraDistance, 30));
            });
            
            // Setup raycaster for interactive objects
            setupRaycaster();
        }
        
        function setupRaycaster() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Listen for mouse movements - throttled for performance
            let mouseMoveTimeout;
            
            document.addEventListener('mousemove', (event) => {
                clearTimeout(mouseMoveTimeout);
                mouseMoveTimeout = setTimeout(() => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                }, 30);
            });
            
            // Listen for clicks
            document.addEventListener('click', (event) => {
                // Update mouse position
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Update raycaster with current mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Check for intersections with interactive objects
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                if (intersects.length > 0) {
                    // Find the closest intersected object
                    let intersectedObject = intersects[0].object;
                    
                    // Traverse up to find parent with userData
                    while(intersectedObject && !intersectedObject.userData.title) {
                        intersectedObject = intersectedObject.parent;
                    }
                    
                    if (intersectedObject && intersectedObject.userData.title) {
                        showModal(intersectedObject.userData.title, intersectedObject.userData.content);
                        
                        // Trigger glitch effect
                        if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                            glitchPass.enabled = true;
                            setTimeout(() => {
                                glitchPass.enabled = false;
                            }, 1000);
                        }
                    }
                }
            });
        }
        
        function showModal(title, content) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalContent').innerHTML = content;
            document.getElementById('modal').style.display = 'block';
        }
        
        function togglePlayerMode() {
            if (playerMode === 'driving') {
                // Exit vehicle
                playerMode = 'walking';
                
                // Position character near car
                character.position.set(
                    car.position.x + Math.sin(car.rotation.y + Math.PI/2) * 3,
                    0,
                    car.position.z + Math.cos(car.rotation.y + Math.PI/2) * 3
                );
                character.rotation.y = car.rotation.y;
                character.visible = true;
                
                // Show exit notification
                const sectionIndicator = document.getElementById('sectionIndicator');
                sectionIndicator.innerHTML = `<span style="color: #006644;">‚óè</span> EXITED VEHICLE <span style="opacity: 0.7; font-size: 0.9em;">[E TO RETURN]</span>`;
                sectionIndicator.style.display = 'block';
                setTimeout(() => {
                    if (playerMode === 'walking') {
                        sectionIndicator.style.display = 'none';
                    }
                }, 3000);
                
                // Glitch effect for transition
                if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                    glitchPass.enabled = true;
                    setTimeout(() => { glitchPass.enabled = false; }, 500);
                }
            } else {
                // Check if close enough to car
                const distanceToCar = character.position.distanceTo(car.position);
                if (distanceToCar < 5) {
                    // Enter vehicle
                    playerMode = 'driving';
                    character.visible = false;
                    
                    // Show entry notification
                    const sectionIndicator = document.getElementById('sectionIndicator');
                    sectionIndicator.innerHTML = `<span style="color: #006644;">‚óè</span> ENTERED VEHICLE`;
                    sectionIndicator.style.display = 'block';
                    setTimeout(() => { sectionIndicator.style.display = 'none'; }, 3000);
                    

                    // Glitch effect for transition
                    if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                        glitchPass.enabled = true;
                        setTimeout(() => { glitchPass.enabled = false; }, 500);
                    }
                } else {
                    // Show too far away message
                    const sectionIndicator = document.getElementById('sectionIndicator');
                    sectionIndicator.innerHTML = `<span style="color: #cc0000;">‚óè</span> TOO FAR FROM VEHICLE`;
                    sectionIndicator.style.display = 'block';
                    setTimeout(() => { sectionIndicator.style.display = 'none'; }, 3000);
                }
            }
        }
        
        function toggleCameraMode() {
            switch(cameraMode) {
                case 'follow':
                    cameraMode = 'orbit';
                    break;
                case 'orbit':
                    cameraMode = 'first-person';
                    break;
                case 'first-person':
                    cameraMode = 'follow';
                    break;
            }
            
            // Show camera mode notification
            const sectionIndicator = document.getElementById('sectionIndicator');
            sectionIndicator.innerHTML = `<span style="color: #0066aa;">‚óè</span> CAMERA: ${cameraMode.toUpperCase()}`;
            sectionIndicator.style.display = 'block';
            setTimeout(() => { sectionIndicator.style.display = 'none'; }, 2000);
        }
        
        // ------------------ ANIMATION & UPDATE FUNCTIONS ------------------
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // Throttle non-essential updates for performance
            updateCounter++;
            
            // Essential updates every frame
            updateVehicleMovement();
            updateCamera();
            updateShaders(elapsedTime);
            updateFPS();
            
            // Throttled updates based on counter 
            if (updateCounter % 2 === 0) {
                updateLights(elapsedTime);
                updateDrones(elapsedTime);
            }
            
            if (updateCounter % 3 === 0) {
                checkSectionProximity();
                updateMinimap();
            }
            
            if (updateCounter % 10 === 0) {
                // Less frequent updates for cloud movement, etc.
                updateClouds(elapsedTime);
            }
            
            // Reset counter to prevent integer overflow
            if (updateCounter > 1000) updateCounter = 0;
            
            // Render scene
            if (composer) {
                renderer.info.reset(); // Clear cached info to prevent memory leak
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        function updateVehicleMovement() {
            if (playerMode === 'driving') {
                updateCar();
            } else {
                updateCharacter();
            }
        }
        
        function updateCar() {
            // Track whether car is moving
            let moving = false;
            
            // Calculate boost multiplier when shift is pressed
            const boostMultiplier = keys['ShiftLeft'] || keys['ShiftRight'] ? 2 : 1;
            const currentMaxSpeed = maxSpeed * boostMultiplier;
            const currentAcceleration = acceleration * boostMultiplier;

            // Forward movement
            if (keys['KeyW'] || keys['ArrowUp']) {
                carSpeed = Math.min(carSpeed + currentAcceleration, currentMaxSpeed);
                moving = true;
            } 
            // Backward movement
            else if (keys['KeyS'] || keys['ArrowDown']) {
                carSpeed = Math.max(carSpeed - currentAcceleration, -currentMaxSpeed * 0.6);
                moving = true;
            }

            // Enhanced steering with speed-based handling
            if (Math.abs(carSpeed) > 0.1) {
                const turnSpeed = 0.03 * (Math.abs(carSpeed) / maxSpeed);
                
                // Left turn
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    car.rotation.y += turnSpeed;
                    
                    // Add subtle tilt for visual effect
                    car.rotation.z = THREE.MathUtils.lerp(
                        car.rotation.z, 
                        Math.min(0.1, turnSpeed * 2), 
                        0.1
                    );
                } 
                // Right turn
                else if (keys['KeyD'] || keys['ArrowRight']) {
                    car.rotation.y -= turnSpeed;
                    
                    // Add subtle tilt for visual effect
                    car.rotation.z = THREE.MathUtils.lerp(
                        car.rotation.z, 
                        Math.max(-0.1, -turnSpeed * 2), 
                        0.1
                    );
                } 
                // Reset tilt when not turning
                else {
                    car.rotation.z = THREE.MathUtils.lerp(car.rotation.z, 0, 0.1);
                }
            }

            // Apply progressive friction when not accelerating
            if (!moving) {
                carSpeed *= (1 - friction);
                if (Math.abs(carSpeed) < 0.02) carSpeed = 0;
            }

            // Calculate movement vector
            const moveVector = new THREE.Vector3(
                Math.sin(car.rotation.y) * carSpeed,
                0,
                Math.cos(car.rotation.y) * carSpeed
            );
            
            // Apply movement
            car.position.add(moveVector);

            // Car tilting effects for acceleration/braking
            car.rotation.x = THREE.MathUtils.lerp(
                car.rotation.x, 
                carSpeed * 0.05, // Tilt forward/backward based on speed
                0.1
            );

            // Update wheels
            car.traverse(child => {
                if (child.userData && child.userData.isWheel) {
                    // Rotate wheels based on speed
                    child.children.forEach(wheelPart => {
                        if (wheelPart.userData && wheelPart.userData.rotationSpeed) {
                            wheelPart.rotation.x += carSpeed * 0.5;
                        }
                        
                        // Update wheel glow effect during boost
                        if (wheelPart.userData && wheelPart.userData.material) {
                            if (boostMultiplier > 1 && Math.abs(carSpeed) > maxSpeed * 0.5) {
                                wheelPart.userData.material.opacity = THREE.MathUtils.lerp(
                                    wheelPart.userData.material.opacity,
                                    0.7,
                                    0.1
                                );
                            } else {
                                wheelPart.userData.material.opacity = THREE.MathUtils.lerp(
                                    wheelPart.userData.material.opacity,
                                    0,
                                    0.1
                                );
                            }
                        }
                    });
                }
            });

            // Update speed display
            const speedKmh = Math.round(Math.abs(carSpeed) * 50);
            let speedText = `Speed: ${speedKmh} km/h`;
            
            // Add boost indicator
            if (boostMultiplier > 1) {
                speedText += " <span style='color:#cc4400'>üöÄ BOOST</span>";
            }
            
            // Add direction indicator
            if (carSpeed < -0.1) {
                speedText += " <span style='color:#cc0000'>‚óÑ REV</span>";
            }
            
            document.getElementById('speed').innerHTML = speedText;
        }
        
        function updateCharacter() {
            if (!character) return;
            
            let moving = false;
            const walkSpeed = 0.1;
            let moveX = 0;
            let moveZ = 0;
            
            // Forward
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveZ += walkSpeed;
                moving = true;
            }
            
            // Backward
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveZ -= walkSpeed;
                moving = true;
            }
            
            // Left
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveX += walkSpeed;
                moving = true;
            }
            
            // Right
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveX -= walkSpeed;
                moving = true;
            }
            
            if (moving) {
                // Set rotation based on movement direction
                if (moveZ !== 0 || moveX !== 0) {
                    character.rotation.y = Math.atan2(moveX, moveZ);
                }
                
                // Apply movement in the direction character is facing
                character.position.x += Math.sin(character.rotation.y) * walkSpeed;
                character.position.z += Math.cos(character.rotation.y) * walkSpeed;
                
                // Update walking animation parameters
                if (!character.userData.walkingAngle) character.userData.walkingAngle = 0;
                if (!character.userData.walkingSpeed) character.userData.walkingSpeed = 0;
                
                character.userData.walkingAngle += 0.2;
                character.userData.walkingSpeed = THREE.MathUtils.lerp(character.userData.walkingSpeed, 1.0, 0.1);
                
                // Apply walking animation to limbs
                if (character.children && character.children.length > 4) {
                    // Legs - we're assuming indexes 4 and 5 are the legs
                    // This would need to be adjusted based on your actual model structure
                    const leftLeg = character.children[4]; 
                    const rightLeg = character.children[5];
                    
                    if (leftLeg && rightLeg) {
                        leftLeg.rotation.x = Math.sin(character.userData.walkingAngle) * 0.4;
                        rightLeg.rotation.x = Math.sin(character.userData.walkingAngle + Math.PI) * 0.4;
                    }
                    
                    // Arms - we're assuming indexes 2 and 3 are the arms
                    const leftArm = character.children[2];
                    const rightArm = character.children[3];
                    
                    if (leftArm && rightArm) {
                        leftArm.rotation.x = Math.sin(character.userData.walkingAngle + Math.PI) * 0.3;
                        rightArm.rotation.x = Math.sin(character.userData.walkingAngle) * 0.3;
                    }
                }
            } else {
                // Slow down walking animation when not moving
                character.userData.walkingSpeed = THREE.MathUtils.lerp(character.userData.walkingSpeed, 0, 0.1);
                
                // Reset character pose
                if (character.children) {
                    // Reset limbs to idle position
                    for (let i = 2; i < 6; i++) { // Assuming arms are 2,3 and legs are 4,5
                        if (character.children[i]) {
                            character.children[i].rotation.x = THREE.MathUtils.lerp(character.children[i].rotation.x, 0, 0.1);
                        }
                    }
                }
            }
        }
        
        function updateCamera() {
            const currentTarget = playerMode === 'driving' ? car : character;
            if (!currentTarget) return;
            
            let targetPosition = new THREE.Vector3();
            let lookAtPosition = new THREE.Vector3();
            
            switch(cameraMode) {
                case 'follow':
                    // Third-person follow camera
                    const followDistance = playerMode === 'driving' ? cameraDistance : 5;
                    const followHeight = playerMode === 'driving' ? cameraHeight : 2;
                    
                    // Calculate ideal offset based on target rotation
                    const idealOffset = new THREE.Vector3(0, followHeight, followDistance);
                    idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), currentTarget.rotation.y);
                    
                    // Calculate target position
                    targetPosition.copy(currentTarget.position).add(idealOffset);
                    
                    // Look ahead of the target
                    lookAtPosition.copy(currentTarget.position).add(
                        new THREE.Vector3(
                            Math.sin(currentTarget.rotation.y) * 10,
                            playerMode === 'driving' ? 2 : 1.7,
                            Math.cos(currentTarget.rotation.y) * 10
                        )
                    );
                    break;
                    
                case 'orbit':
                    // Orbiting camera that circles around the target
                    cameraAngle += 0.005;
                    const orbitRadius = playerMode === 'driving' ? 15 : 5;
                    const orbitHeight = playerMode === 'driving' ? 8 : 3;
                    
                    targetPosition.set(
                        currentTarget.position.x + Math.sin(cameraAngle) * orbitRadius,
                        currentTarget.position.y + orbitHeight,
                        currentTarget.position.z + Math.cos(cameraAngle) * orbitRadius
                    );
                    
                    lookAtPosition.copy(currentTarget.position).add(
                        new THREE.Vector3(0, playerMode === 'driving' ? 2 : 1.7, 0)
                    );
                    break;
                    
                case 'first-person':
                    if (playerMode === 'driving') {
                        // Car first-person (driver seat)
                        targetPosition.copy(car.position).add(
                            new THREE.Vector3(
                                Math.sin(car.rotation.y) * 0.5,
                                1.8,
                                Math.cos(car.rotation.y) * 0.5
                            )
                        );
                        
                        // Look forward from driver's perspective
                        lookAtPosition.copy(targetPosition).add(
                            new THREE.Vector3(
                                Math.sin(car.rotation.y) * 10,
                                0,
                                Math.cos(car.rotation.y) * 10
                            )
                        );
                    } else {
                        // Character first-person
                        targetPosition.copy(character.position).add(
                            new THREE.Vector3(0, 1.7, 0)
                        );
                        
                        // Look forward from character's perspective
                        lookAtPosition.copy(targetPosition).add(
                            new THREE.Vector3(
                                Math.sin(character.rotation.y) * 10,
                                0,
                                Math.cos(character.rotation.y) * 10
                            )
                        );
                    }
                    break;
            }
            
            // Apply camera smoothing
            camera.position.lerp(targetPosition, cameraMode === 'first-person' ? 0.5 : 0.1);
            
            // Create temporary vector for smooth look-at
            const currentLookAt = new THREE.Vector3();
            currentLookAt.copy(lookAtPosition);
            
            // Apply look-at
            camera.lookAt(currentLookAt);
            
            // Add camera shake when boosting in the car
            if (playerMode === 'driving' && (keys['ShiftLeft'] || keys['ShiftRight']) && Math.abs(carSpeed) > maxSpeed * 0.5) {
                const shakeIntensity = Math.abs(carSpeed) * 0.005;
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                camera.position.z += (Math.random() - 0.5) * shakeIntensity;
            }
        }
        
        function updateShaders(elapsedTime) {
            // Update all shader materials with time uniform
            neonSigns.forEach(object => {
                if (object && object.material && object.material.uniforms && object.material.uniforms.time) {
                    object.material.uniforms.time.value = elapsedTime;
                }
            });
            
            // Update particle systems
            particleSystems.forEach(particles => {
                if (particles && particles.material && particles.material.uniforms && particles.material.uniforms.time) {
                    particles.material.uniforms.time.value = elapsedTime;
                }
            });
            
            // Update road strip materials if using instanced meshes
            if (instancedObjects.roadStrips) {

                instancedObjects.roadStrips.forEach(strips => {
                    if (strips.material && strips.material.uniforms && strips.material.uniforms.time) {
                        strips.material.uniforms.time.value = elapsedTime;
                    }
                });
            }
        }
        
        function updateLights(elapsedTime) {
            // Update city lights with more subtle effects for daylight
            cityLights.forEach(light => {
                if (!light.userData.pulseSpeed) {
                    light.userData.pulseSpeed = 0.3 + Math.random() * 1.5; // Reduced variation
                }
                
                // Much more subtle light animation for daylight
                const pulseIntensity = 0.2 + Math.sin(elapsedTime * light.userData.pulseSpeed) * 0.1; // Reduced range
                light.intensity = light.userData.baseIntensity || (pulseIntensity * 0.3); // Further reduced for daylight
                
                // Store base intensity if not already stored
                if (!light.userData.baseIntensity) {
                    light.userData.baseIntensity = light.intensity;
                }
            });
        }
        
        function updateDrones(elapsedTime) {
            // Update drone movements
            drones.forEach(drone => {
                if (!drone || !drone.userData || !drone.userData.movement) return;
                
                // Different movement behavior based on drone type
                if (drone.userData.movement.angle !== undefined) {
                    // Circular movement pattern for surveillance drones
                    drone.userData.movement.angle += drone.userData.movement.speed;
                    
                    drone.position.set(
                        drone.userData.movement.centerX + Math.sin(drone.userData.movement.angle) * drone.userData.movement.radius,
                        drone.userData.movement.height + Math.sin(elapsedTime * drone.userData.movement.verticalSpeed) * drone.userData.movement.verticalRange,
                        drone.userData.movement.centerZ + Math.cos(drone.userData.movement.angle) * drone.userData.movement.radius
                    );
                    
                    // Make drones rotate in their movement direction
                    drone.rotation.y = -drone.userData.movement.angle + Math.PI / 2;
                } else {
                    // Random wobble for other flying objects
                    drone.position.y += Math.sin(elapsedTime * drone.userData.movement.wobbleSpeed) * drone.userData.movement.wobble;
                    
                    // Small random horizontal movement
                    drone.position.x += (Math.random() - 0.5) * 0.05;
                    drone.position.z += (Math.random() - 0.5) * 0.05;
                    
                    // Keep within radius
                    const distFromCenter = Math.sqrt(drone.position.x * drone.position.x + drone.position.z * drone.position.z);
                    if (distFromCenter > drone.userData.movement.radius) {
                        const angle = Math.atan2(drone.position.x, drone.position.z);
                        drone.position.x = Math.sin(angle) * drone.userData.movement.radius;
                        drone.position.z = Math.cos(angle) * drone.userData.movement.radius;
                    }
                }
                
                // Update propellers and mechanical parts
                drone.traverse(child => {
                    if (child.userData && child.userData.rotationSpeed) {
                        child.rotation.y += child.userData.rotationSpeed;
                    }
                    
                    // Animate wings for insects/butterflies
                    if (child.userData && child.userData.isWing) {
                        if (!drone.userData.movement.wingSpeed) {
                            drone.userData.movement.wingSpeed = 0.2 + Math.random() * 0.3;
                        }
                        
                        const wingAngle = Math.sin(elapsedTime * drone.userData.movement.wingSpeed * 10) * Math.PI / 4;
                        
                        if (child.userData.side === 'left') {
                            child.rotation.x = wingAngle;
                        } else {
                            child.rotation.x = -wingAngle;
                        }
                    }
                });
            });
        }
        
        function checkSectionProximity() {
            // Skip if modal is open
            if (document.getElementById('modal').style.display === 'block') return;
            
            // Determine current active object (car or character)
            const activePosition = playerMode === 'driving' ? car.position : character.position;
            
            // Reset current section
            let closestSection = null;
            let closestDistance = 20; // Minimum distance to consider "near" a section
            
            // Check proximity to buildings
            sections.forEach(section => {
                const distance = activePosition.distanceTo(section.position);
                
                if (distance < closestDistance) {
                    closestSection = section;
                    closestDistance = distance;
                }
            });
            
            if (closestSection !== currentSection) {
                // New section is closest
                currentSection = closestSection;
                
                // Update section indicator
                const sectionIndicator = document.getElementById('sectionIndicator');
                
                if (currentSection) {
                    const title = currentSection.userData.title;
                    const hexColor = '#' + currentSection.userData.color.toString(16).padStart(6, '0');
                    
                    sectionIndicator.innerHTML = `<span style="color: ${hexColor};">‚óè</span> ${title} <span style="opacity: 0.7; font-size: 0.9em;">[SPACE TO ENTER]</span>`;
                    sectionIndicator.style.display = 'block';
                    
                    // Brief glitch effect near important locations - reduced intensity
                    if (glitchPass && qualitySettings.effectsLevel !== 'minimal') {
                        glitchPass.enabled = true;
                        glitchPass.strength = 0.2; // Reduced from default
                        setTimeout(() => { 
                            glitchPass.enabled = false;
                            glitchPass.strength = 0.5; // Restore default
                        }, 150); // Shorter duration
                    }
                } else {
                    sectionIndicator.style.display = 'none';
                }
            }
        }
        
        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            const ctx = minimap.getContext('2d');
            
            // Set canvas size if not already set
            if (minimap.width !== minimap.offsetWidth || minimap.height !== minimap.offsetHeight) {
                minimap.width = minimap.offsetWidth;
                minimap.height = minimap.offsetHeight;
            }
            
            // Clear minimap with a more subtle background
            ctx.fillStyle = 'rgba(245, 250, 250, 0.85)';
            ctx.fillRect(0, 0, minimap.width, minimap.height);
            
            // Draw subtle grid lines
            ctx.strokeStyle = 'rgba(0, 119, 85, 0.15)';
            ctx.lineWidth = 1;
            
            // Draw grid
            const gridSize = 20;
            for (let i = 0; i <= minimap.width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, minimap.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= minimap.height; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(minimap.width, i);
                ctx.stroke();
            }
            
            // Center and scale for minimap
            const centerX = minimap.width / 2;
            const centerY = minimap.height / 2;
            const scale = 1.5; // Adjust to show more or less of the map
            
            // Draw main road
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.6)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, minimap.height);
            ctx.stroke();
            
            // Draw buildings as colored dots
            sections.forEach(section => {
                const x = centerX + section.position.x / scale;
                const y = centerY + section.position.z / scale;
                
                // Draw building dot
                const colorHex = section.userData.color.toString(16).padStart(6, '0');
                ctx.fillStyle = '#' + colorHex;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw building outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Draw player position based on mode
            const playerPosition = playerMode === 'driving' ? car.position : character.position;
            
            const playerX = centerX + playerPosition.x / scale;
            const playerY = centerY + playerPosition.z / scale;
            
            // Direction indicator
            const angle = playerMode === 'driving' ? car.rotation.y : character.rotation.y;
            
            // Draw player position
            ctx.save();
            ctx.translate(playerX, playerY);
            ctx.rotate(-angle);
            
            // Different marker for driving vs walking
            if (playerMode === 'driving') {
                // Car icon
                ctx.fillStyle = 'rgba(204, 0, 68, 0.9)';
                ctx.beginPath();
                ctx.moveTo(0, -6); // Front
                ctx.lineTo(-4, 4);  // Back left
                ctx.lineTo(4, 4);   // Back right
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                // Person icon
                ctx.fillStyle = 'rgba(0, 102, 204, 0.9)';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function updateClouds(elapsedTime) {
            // Update cloud positions
            scene.traverse(object => {
                if (!object.userData || !object.userData.drift) return;
                
                // Get cloud drift data
                const drift = object.userData.drift;
                
                // Update cloud time
                drift.time += drift.speed;
                
                // Calculate new position with drifting motion
                const newX = drift.initialX + Math.sin(drift.time * 0.3) * drift.distance;
                const newZ = drift.initialZ + Math.cos(drift.time * 0.2) * drift.distance;
                
                // Apply new position
                object.position.x = newX;
                object.position.z = newZ;
                
                // Slow rotation
                object.rotation.y += 0.001;
            });
        }
        
        function updateFPS() {
            // Update FPS counter every ~500ms
            const now = performance.now();
            
            frameCount++;
            
            if (now - lastTime >= 500) {
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                
                // Reset counters
                lastTime = now;
                frameCount = 0;
                
                // Adjust quality settings automatically if running poorly
                if (fps < 30 && !isMobile && qualitySettings.effectsLevel !== 'minimal') {
                    // Automatically reduce quality
                    const currentQuality = document.getElementById('qualitySelect').value;
                    const currentEffects = document.getElementById('effectsSelect').value;
                    
                    if (currentEffects === 'ultra') {
                        document.getElementById('effectsSelect').value = 'balanced';
                        applySettings();
                    } else if (currentQuality === 'high' && currentEffects === 'balanced') {
                        document.getElementById('qualitySelect').value = 'medium';
                        applySettings();
                    } else if (currentQuality === 'medium' && fps < 20) {
                        document.getElementById('qualitySelect').value = 'low';
                        document.getElementById('effectsSelect').value = 'minimal';
                        applySettings();
                    }
                }
            }
        }
        
        // Modify the setupPostProcessing function to reduce white flashes
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            // Standard render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Optimization: Only add FXAA on medium/high quality
            if (qualitySettings.quality !== 'low') {
                const fxaaPass = new ShaderPass(FXAAShader);
                const pixelRatio = renderer.getPixelRatio();
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
                composer.addPass(fxaaPass);
            }
            
            // Bloom pass with significantly reduced intensity to avoid white flashes
            let bloomStrength, bloomRadius, bloomThreshold;
            
            switch(qualitySettings.postProcessing) {
                case 'minimal':
                    bloomStrength = 0.1; // Much lower strength
                    bloomRadius = 0.3;
                    bloomThreshold = 0.98; // Higher threshold to reduce bloom on bright areas
                    break;
                case 'balanced':
                    bloomStrength = 0.15;
                    bloomRadius = 0.25;
                    bloomThreshold = 0.95;
                    break;
                case 'full':
                    bloomStrength = 0.18;
                    bloomRadius = 0.2;
                    bloomThreshold = 0.9;
                    break;
            }
            
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                bloomStrength,
                bloomRadius,
                bloomThreshold
            );
            composer.addPass(bloomPass);
            
            // Only add glitch pass on high-end devices, with reduced intensity
            if (qualitySettings.effectsLevel === 'ultra') {
                glitchPass = new GlitchPass(0.3); // Reduced intensity
                glitchPass.enabled = false; // Only enable at specific moments
                composer.addPass(glitchPass);
            }
        }
        
        // Replace building creation functions with more realistic versions
        function createPortfolioSections() {
            // Create reusable geometries
            const buildingGeoCache = {};
            
            // Create a single template mesh for each building type
            function getBuildingGeometry(type, params) {
                const cacheKey = `${type}-${JSON.stringify(params)}`;
                
                if (buildingGeoCache[cacheKey]) {
                    return buildingGeoCache[cacheKey];
                }
                
                let geometry;
                
                switch(type) {
                    case 'box':
                        geometry = getGeometry('box', params, qualitySettings.geometryDetail);
                        break;
                    case 'cylinder':
                        geometry = getGeometry('cylinder', params, qualitySettings.geometryDetail);
                        break;
                    case 'cone':
                        geometry = getGeometry('cone', params, qualitySettings.geometryDetail);
                        break;
                    case 'sphere':
                        geometry = getGeometry('sphere', params, qualitySettings.geometryDetail);
                        break;
                }
                
                buildingGeoCache[cacheKey] = geometry;
                return geometry;
            }
            
            // Create building base materials with realistic properties and reduced emission
            function createBuildingMaterial(color, intensity) {
                // Mute the color by mixing with gray for more realism
                const mutedColor = new THREE.Color(color).lerp(new THREE.Color(0x888888), 0.3);
                const hexColor = mutedColor.getHex();
                
                const cacheKey = `building-${hexColor}-${intensity}`;
                
                return createMaterial('physical', {
                    color: hexColor,
                    metalness: 0.5,
                    roughness: 0.5,
                    emissive: hexColor,
                    emissiveIntensity: intensity * 0.1, // Significantly reduced for daylight
                    clearcoat: 0.2,
                    clearcoatRoughness: 0.6
                }, cacheKey);
            }
            
            // Process each section with optimized creation
            Object.entries(portfolioData).forEach(([title, data]) => {
                const sectionGroup = new THREE.Group();
                
                // Randomize building style for variety
                const buildingType = Math.floor(Math.random() * 4);
                const height = 20 + Math.random() * 30;
                
                // Create base building with realistic style
                let buildingMesh;
                
                switch(buildingType) {
                    case 0: // Modern office building
                        buildingMesh = createModernSkyscraper(data.color, height);
                        break;
                    case 1: // Glass dome structure
                        buildingMesh = createGlassBuilding(data.color, height);
                        break;
                    case 2: // Staggered terrace structure
                        buildingMesh = createTerraceBuilding(data.color, height);
                        break;
                    case 3: // Contemporary tower
                        buildingMesh = createContemporaryTower(data.color, height);
                        break;
                }
                
                sectionGroup.add(buildingMesh);
                
                // Add holographic projection above building - more subtle version
                if (qualitySettings.effectsLevel !== 'minimal') {
                    const holoProjection = createSubtleHologram(title, data.color);
                    holoProjection.position.y = height + 8;
                    sectionGroup.add(holoProjection);
                    hologramProjections.push(holoProjection);
                } else {
                    // Add simple sign for minimal effects mode
                    const signGeometry = getGeometry('plane', { width: 6, height: 2 });
                    
                    // Create canvas texture for sign
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw sign text with better contrast for daylight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(0, 0, 512, 128);
                    ctx.fillStyle = `rgb(
                        ${Math.min(255, ((data.color >> 16) & 255) * 0.7)},
                        ${Math.min(255, ((data.color >> 8) & 255) * 0.7)},
                        ${Math.min(255, (data.color & 255) * 0.7)}
                    )`;
                    ctx.font = 'bold 60px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(title.toUpperCase(), 256, 64);
                    
                    const signTexture = new THREE.CanvasTexture(canvas);
                    const signMaterial = createMaterial('basic', {
                        map: signTexture,
                        side: THREE.DoubleSide
                    });
                    
                    const sign = new THREE.Mesh(signGeometry, signMaterial);
                    sign.position.set(0, height + 5, 0);
                    sign.lookAt(0, height, 0); // Always face the center
                    sectionGroup.add(sign);
                }
                
                // Add entrance portal with interactive elements - more subtle colors
                const portalGeometry = getGeometry('box', { 
                    width: 5, 
                    height: 8, 
                    depth: 1 
                }, qualitySettings.geometryDetail);
                
                const portalMaterial = createShaderMaterial({
                    time: { value: 0 },
                    color: { value: new THREE.Color(data.color).lerp(new THREE.Color(0xFFFFFF), 0.2) }
                }, 
                // Vertex shader
                `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment shader (optimized for daylight with reduced brightness)
                `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 center = vUv - vec2(0.5);
                        float dist = length(center);
                        
                        // Create portal effect (simplified)
                        float ripple = sin(dist * 20.0 - time * 2.0) * 0.5 + 0.5;
                        ripple *= smoothstep(0.5, 0.4, dist);
                        
                        // Energy edges 
                        float edge = smoothstep(0.5, 0.45, dist) - smoothstep(0.45, 0.4, dist);
                        
                        // Combine effects - more natural colors for daylight visibility
                        vec3 finalColor = mix(
                            color * 0.5, // Darker base
                            color * 0.9, // Less bright highlights
                            ripple + edge
                        );
                        
                        float alpha = smoothstep(0.5, 0.4, dist) * 0.6; // Reduced opacity
                        alpha = mix(alpha, 0.8, edge);
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                {
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.NormalBlending
                });
                
                const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                portal.position.set(0, 4, 8); // Position at front of building
                sectionGroup.add(portal);
                
                // Store portal for animation updates
                neonSigns.push(portal);
                
                // Add energy field around building (only for high effects) with reduced brightness
                if (qualitySettings.effectsLevel === 'ultra') {
                    const energyField = createSubtleEnergyField(data.color);
                    energyField.scale.set(12, height * 0.6, 12);
                    energyField.position.y = height * 0.3;
                    sectionGroup.add(energyField);
                }
                
                // Position section according to data
                sectionGroup.position.set(data.position.x, 0, data.position.z);
                sectionGroup.userData = { 
                    title, 
                    content: data.content,
                    color: data.color
                };
                
                sections.push(sectionGroup);
                buildings.push(sectionGroup);
                scene.add(sectionGroup);
            });

            // Helper functions for building creation with realistic architecture
            function createModernSkyscraper(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base structure with realistic proportions
                const baseGeometry = getBuildingGeometry('box', {
                    width: 14, 
                    height: height, 
                    depth: 14
                });
                
                const baseMaterial = createBuildingMaterial(color, 0.05); // Reduced emissive for realism
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = height / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Building facade with texture
                if (qualitySettings.quality !== 'low') {
                    // Create window grid texture for facades
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw background
                    ctx.fillStyle = '#' + new THREE.Color(color).getHexString();
                    ctx.fillRect(0, 0, 512, 512);
                    
                    // Draw window pattern - more realistic spacing
                    ctx.fillStyle = '#aadeff';
                    
                    const windowRows = 25;
                    const windowCols = 12;
                    const windowWidth = 30;
                    const windowHeight = 14;
                    const marginX = 10;
                    const marginY = 6;
                    
                    for (let y = 0; y < windowRows; y++) {
                        for (let x = 0; x < windowCols; x++) {
                            // Skip some windows randomly for realism
                            if (Math.random() > 0.9) continue;
                            
                            // Draw window with slight brightness variation
                            const brightness = 170 + Math.round(Math.random() * 50);
                            ctx.fillStyle = `rgb(${brightness}, ${brightness+20}, ${brightness+40})`;
                            
                            ctx.fillRect(
                                x * (windowWidth + marginX) + marginX,
                                y * (windowHeight + marginY) + marginY,
                                windowWidth,
                                windowHeight
                            );
                        }
                    }
                    
                    // Create texture
                    const facadeTexture = new THREE.CanvasTexture(canvas);
                    facadeTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    
                    // Create facade materials with normal map for depth
                    const facadeMaterial = createMaterial('physical', {
                        map: facadeTexture,
                        normalScale: new THREE.Vector2(0.1, 0.1),
                        roughness: 0.6,
                        metalness: 0.4,
                        clearcoat: 0.1
                    }, `facade-${color}`);
                    
                    // Apply facade to all four sides
                    const facadeGeometry = getGeometry('plane', {
                        width: 14.01,
                        height: height
                    }, detailLevel);
                    
                    // Create facades for all sides
                    const directions = [
                        { position: [0, 0, 7.01], rotation: [0, 0, 0] },
                        { position: [0, 0, -7.01], rotation: [0, Math.PI, 0] },
                        { position: [7.01, 0, 0], rotation: [0, -Math.PI/2, 0] },
                        { position: [-7.01, 0, 0], rotation: [0, Math.PI/2, 0] }
                    ];
                    
                    directions.forEach(dir => {
                        const facade = new THREE.Mesh(facadeGeometry, facadeMaterial);
                        facade.position.set(dir.position[0], height/2, dir.position[2]);
                        facade.rotation.set(dir.rotation[0], dir.rotation[1], dir.rotation[2]);
                        facade.receiveShadow = qualitySettings.shadowsEnabled;
                        group.add(facade);
                    });
                }
                
                // Add architectural details for higher quality settings
                if (qualitySettings.quality !== 'low') {
                    // Add crown on top
                    const crownGeometry = getBuildingGeometry('box', {
                        width: 16, 
                        height: 4, 
                        depth: 16
                    });
                    
                    const crownMaterial = createBuildingMaterial(0x888888, 0.05);
                    const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                    crown.position.y = height + 2;
                    crown.castShadow = qualitySettings.shadowsEnabled;
                    group.add(crown);
                    
                    // Add rooftop mechanical structures
                    const mechanicalStructures = [
                        { size: [3, 6, 3], position: [4, height + 5, -3] },
                        { size: [2, 4, 2], position: [-3, height + 4, 4] },
                        { size: [4, 3, 3], position: [1, height + 3.5, 3] }
                    ];
                    
                    mechanicalStructures.forEach(struct => {
                        const mechGeometry = getBuildingGeometry('box', {
                            width: struct.size[0], 
                            height: struct.size[1], 
                            depth: struct.size[2]
                        });
                        
                        const mechMaterial = createBuildingMaterial(0x777777, 0);
                        const mechStruct = new THREE.Mesh(mechGeometry, mechMaterial);
                        mechStruct.position.set(struct.position[0], struct.position[1], struct.position[2]);
                        mechStruct.castShadow = qualitySettings.shadowsEnabled;
                        group.add(mechStruct);
                    });
                    
                    // Add entrance details
                    const entranceGeometry = getBuildingGeometry('box', {
                        width: 10,
                        height: 10,
                        depth: 6
                    });
                    
                    const entranceMaterial = createBuildingMaterial(color, 0.05);
                    const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
                    entrance.position.set(0, 5, 10);
                    entrance.castShadow = qualitySettings.shadowsEnabled;
                    group.add(entrance);
                    
                    // Add columns at entrance
                    [-3.5, 3.5].forEach(xPos => {
                        const columnGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: 0.7,
                            radiusBottom: 0.7,
                            height: 9,
                            radialSegments: 8
                        });
                        
                        const columnMaterial = createBuildingMaterial(0xCCCCCC, 0);
                        const column = new THREE.Mesh(columnGeometry, columnMaterial);
                        column.position.set(xPos, 4.5, 13);
                        column.castShadow = qualitySettings.shadowsEnabled;
                        group.add(column);
                    });
                    
                    // Add solar panels on roof for eco-friendly appeal
                    const panelGeometry = getBuildingGeometry('box', {
                        width: 2.5, 
                        height: 0.2, 
                        depth: 4
                    }, detailLevel);
                    
                    const panelMaterial = createMaterial('physical', {
                        color: 0x2244AA,
                        metalness: 0.8,
                        roughness: 0.3,
                        clearcoat: 0.5,
                        clearcoatRoughness: 0.1
                    }, 'building-solar');
                    
                    // Add multiple panels in a row
                    for (let i = 0; i < 3; i++) {
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        panel.position.set(-5 + i * 4, height + 6, 0);
                        panel.rotation.x = Math.PI / 6; // Tilt toward sun
                        panel.castShadow = qualitySettings.shadowsEnabled;
                        group.add(panel);
                    }
                }
                
                return group;
            }
            
            function createGlassBuilding(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base structure with organic shape
                const baseHeight = height * 0.5;
                const baseSegments = qualitySettings.quality === 'low' ? 12 : 16;
                
                const baseGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 8,
                    radiusBottom: 12,
                    height: baseHeight,
                    radialSegments: baseSegments
                });
                
                // Create realistic glass material with reduced brightness
                const baseMaterial = createMaterial('physical', {
                    color: 0xEEEEEE,
                    metalness: 0.3,
                    roughness: 0.2,
                    transmission: 0.2, // Some transparency for glass look
                    thickness: 0.5,
                    envMapIntensity: 1.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                }, 'glass-base');
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = baseHeight / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Create glass panels for facade
                if (qualitySettings.quality !== 'low') {
                    const panelCount = Math.max(6, Math.floor(baseSegments * 0.75));
                    
                    for (let i = 0; i < panelCount; i++) {
                        const angle = (i / panelCount) * Math.PI * 2;
                        
                        // Create vertical glass panel
                        const panelHeight = baseHeight * 0.9;
                        const panelWidth = Math.PI * 24 / panelCount * 0.7; // Width based on circumference
                        
                        const panelGeometry = getGeometry('plane', {
                            width: panelWidth,
                            height: panelHeight
                        }, detailLevel);
                        
                        // Create glass material with varying reflectivity
                        const blueShade = 0.4 + Math.random() * 0.3; // Varying blue tint
                        const panelMaterial = createMaterial('physical', {
                            color: new THREE.Color(0.7, 0.8, blueShade),
                            metalness: 0.8,
                            roughness: 0.1,
                            clearcoat: 1.0,
                            clearcoatRoughness: 0.03,
                            envMapIntensity: 1.5
                        });
                        
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        
                        // Position panel on cylinder surface
                        panel.position.set(
                            Math.sin(angle) * 10,
                            baseHeight / 2,
                            Math.cos(angle) * 10
                        );
                        
                        // Rotate to face outward
                        panel.rotation.y = Math.PI / 2 + angle;
                        
                        panel.castShadow = qualitySettings.shadowsEnabled;
                        group.add(panel);
                    }
                }
                
                // Glass dome
                const domeSegments = qualitySettings.quality === 'low' ? 16 : 
                                     qualitySettings.quality === 'medium' ? 24 : 32;
                
                const domeGeometry = getBuildingGeometry('sphere', {
                    radius: 12,
                    widthSegments: domeSegments,
                    heightSegments: Math.floor(domeSegments / 2),
                    phiStart: 0, 
                    phiLength: Math.PI * 2,
                    thetaStart: 0, 
                    thetaLength: Math.PI / 2
                });
                
                const domeMaterial = createMaterial('physical', {
                    color: new THREE.Color(color).lerp(new THREE.Color(0xFFFFFF), 0.7), // Much lighter color
                    metalness: 0.2,
                    roughness: 0.1,
                    transmission: 0.7,
                    thickness: 0.5,
                    envMapIntensity: 1.3,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                }, `dome-${color}`);
                
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = baseHeight;
                dome.castShadow = qualitySettings.shadowsEnabled;
                group.add(dome);
                
                // Add structural supports
                if (qualitySettings.quality !== 'low') {
                    // Scale number of supports based on quality
                    const supportCount = qualitySettings.quality === 'high' ? 8 : 6;
                    
                    // Create realistic structural ring at base of dome
                    const ringGeometry = getBuildingGeometry('torus', {
                        radius: 12,
                        tube: 0.5,
                        radialSegments: 8,
                        tubularSegments: supportCount * 4
                    }, detailLevel);
                    
                    const ringMaterial = createMaterial('standard', {
                        color: 0xAAAAAA,
                        metalness: 0.8,
                        roughness: 0.2
                    }, 'building-ring');
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = baseHeight;
                    ring.rotation.x = Math.PI / 2;
                    ring.castShadow = qualitySettings.shadowsEnabled;
                    group.add(ring);
                    
                    // Create structural supports
                    for (let i = 0; i < supportCount; i++) {
                        const angle = (i / supportCount) * Math.PI * 2;
                        
                        // Thicker, more realistic supports
                        const supportGeometry = getBuildingGeometry('box', {
                            width: 0.5, 
                            height: baseHeight, 
                            depth: 0.8
                        });
                        
                        const supportMaterial = createMaterial('standard', {
                            color: 0xAAAAAA,
                            metalness: 0.8,
                            roughness: 0.2
                        }, 'building-support');
                        
                        const support = new THREE.Mesh(supportGeometry, supportMaterial);
                        support.position.set(
                            Math.sin(angle) * 11.5,
                            baseHeight / 2,
                            Math.cos(angle) * 11.5
                        );
                        
                        // Angle supports slightly for architectural interest
                        support.rotation.y = angle;
                        
                        support.castShadow = qualitySettings.shadowsEnabled;
                        group.add(support);
                        
                        // Vertical dome supports (arches)
                        const archGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: 0.3,
                            radiusBottom: 0.3,
                            height: 14,
                            radialSegments: 8
                        }, detailLevel);
                        
                        const arch = new THREE.Mesh(archGeometry, supportMaterial);
                        
                        // Position at edge of dome
                        arch.position.set(
                            Math.sin(angle) * 12,
                            baseHeight + 7,
                            Math.cos(angle) * 12
                        );
                        
                        // Rotate to point toward dome center
                        arch.rotation.z = Math.PI / 2 - Math.PI / 4;
                        arch.rotation.y = angle + Math.PI;
                        
                        arch.castShadow = qualitySettings.shadowsEnabled;
                        group.add(arch);
                    }
                    
                    // Add interior architectural details
                    const interiorFloors = 3;
                    const floorHeight = baseHeight / interiorFloors;
                    
                    for (let i = 1; i < interiorFloors; i++) {
                        const floorY = i * floorHeight;
                        
                        // Floor disk
                        const floorGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: 11.5,
                            radiusBottom: 11.5,
                            height: 0.3,
                            radialSegments: 32
                        }, detailLevel);
                        
                        const floorMaterial = createMaterial('standard', {
                            color: 0xDDDDDD,
                            metalness: 0.1,
                            roughness: 0.8
                        }, 'building-floor');
                        
                        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                        floor.position.y = floorY;
                        floor.castShadow = qualitySettings.shadowsEnabled;
                        floor.receiveShadow = qualitySettings.shadowsEnabled;
                        group.add(floor);
                        
                        // Central column
                        if (i === 1) {
                            const columnGeometry = getBuildingGeometry('cylinder', {
                                radiusTop: 2,
                                radiusBottom: 3,
                                height: baseHeight,
                                radialSegments: 16
                            }, detailLevel);
                            
                            const columnMaterial = createMaterial('standard', {
                                color: 0xCCCCCC,
                                metalness: 0.2,
                                roughness: 0.8
                            }, 'building-column');
                            
                            const column = new THREE.Mesh(columnGeometry, columnMaterial);
                            column.position.y = baseHeight / 2;
                            column.castShadow = qualitySettings.shadowsEnabled;
                            column.receiveShadow = qualitySettings.shadowsEnabled;
                            group.add(column);
                        }
                    }
                    
                    // Add entrance features
                    const entranceWidth = 6;
                    
                    // Entrance path
                    const pathGeometry = getBuildingGeometry('box', {
                        width: entranceWidth,
                        height: 0.1,
                        depth: 8
                    }, detailLevel);
                    
                    const pathMaterial = createMaterial('standard', {
                        color: 0x999999,
                        metalness: 0,
                        roughness: 0.9
                    }, 'building-path');
                    
                    const path = new THREE.Mesh(pathGeometry, pathMaterial);
                    path.position.set(0, 0.05, 15);
                    path.receiveShadow = qualitySettings.shadowsEnabled;
                    group.add(path);
                    
                    // Entrance stairs
                    const stairsGeometry = getBuildingGeometry('box', {
                        width: entranceWidth + 2,
                        height: 0.5,
                        depth: 2
                    }, detailLevel);
                    
                    const stairs = new THREE.Mesh(stairsGeometry, pathMaterial);
                    stairs.position.set(0, 0.25, 11);
                    stairs.receiveShadow = qualitySettings.shadowsEnabled;
                    group.add(stairs);
                }
                
                return group;
            }
            
            function createTerraceBuilding(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Color variations for different sections
                const mutedColor = new THREE.Color(color).lerp(new THREE.Color(0x888888), 0.3);
                const darkColor = new THREE.Color(color).lerp(new THREE.Color(0x222222), 0.5);
                
                // Base structure
                const baseHeight = height * 0.3;
                const baseWidth = 20;
                const baseDepth = 20;
                
                const baseGeometry = getBuildingGeometry('box', {
                    width: baseWidth,
                    height: baseHeight,
                    depth: baseDepth
                });
                
                const baseMaterial = createBuildingMaterial(darkColor, 0.05);
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = baseHeight / 2;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Create terraced layers
                const terraceCount = 6;
                let currentHeight = baseHeight;
                
                for (let i = 0; i < terraceCount; i++) {
                    const ratio = 1 - (i / terraceCount) * 0.7; // Gradual size reduction
                    const terraceWidth = baseWidth * ratio;
                    const terraceDepth = baseDepth * ratio;
                    const terraceHeight = height * 0.1;
                    
                    const terraceGeometry = getBuildingGeometry('box', {
                        width: terraceWidth,
                        height: terraceHeight,
                        depth: terraceDepth
                    });
                    
                    // Alternate materials for visual interest
                    const terraceMaterial = createBuildingMaterial(
                        i % 2 === 0 ? mutedColor : darkColor,
                        0.05
                    );
                    
                    const terrace = new THREE.Mesh(terraceGeometry, terraceMaterial);
                    terrace.position.y = currentHeight + terraceHeight / 2;
                    terrace.castShadow = qualitySettings.shadowsEnabled;
                    terrace.receiveShadow = qualitySettings.shadowsEnabled;
                    group.add(terrace);
                    
                    currentHeight += terraceHeight;
                    
                    // Add garden features to terraces for medium/high quality
                    if (qualitySettings.quality !== 'low' && i > 0) {
                        // Add planters at edges
                        const planterWidth = terraceWidth * 0.8;
                        const planterDepth = 2;
                        const planterHeight = 1;
                        
                        // North edge planter
                        const planterGeometry = getBuildingGeometry('box', {
                            width: planterWidth,
                            height: planterHeight,
                            depth: planterDepth
                        }, detailLevel);
                        
                        const planterMaterial = createMaterial('standard', {
                            color: 0x666666,
                            roughness: 0.8,
                            metalness: 0.2
                        }, 'terrace-planter');
                        
                        const northPlanter = new THREE.Mesh(planterGeometry, planterMaterial);
                        northPlanter.position.set(
                            0,
                            currentHeight - terraceHeight / 2,
                            -terraceDepth / 2 + planterDepth / 2
                        );
                        northPlanter.castShadow = qualitySettings.shadowsEnabled;
                        northPlanter.receiveShadow = qualitySettings.shadowsEnabled;
                        group.add(northPlanter);
                        
                        // Add greenery
                        if (qualitySettings.quality === 'high') {
                            const foliageGeometry = getBuildingGeometry('box', {
                                width: planterWidth * 0.9,
                                height: 0.8,
                                depth: planterDepth * 0.9
                            }, detailLevel);
                            
                            const foliageMaterial = createMaterial('standard', {
                                color: 0x226622,
                                roughness: 1.0,
                                metalness: 0
                            }, 'terrace-plants');
                            
                            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                            foliage.position.y = 0.8 / 2;
                            northPlanter.add(foliage);
                        }
                        
                        // Only add more planters for high quality to save performance
                        if (qualitySettings.quality === 'high') {
                            // South edge planter
                            const southPlanter = northPlanter.clone();
                            southPlanter.position.z = terraceDepth / 2 - planterDepth / 2;
                            group.add(southPlanter);
                            
                            // Add railing for safety
                            const railingHeight = 1.2;
                            const railingGeometry = getBuildingGeometry('cylinder', {
                                radiusTop: 0.05,
                                radiusBottom: 0.05,
                                height: railingHeight,
                                radialSegments: 6
                            }, detailLevel);
                            
                            const railingMaterial = createMaterial('standard', {
                                color: 0x888888,
                                roughness: 0.5,
                                metalness: 0.5
                            }, 'terrace-railing');
                            
                            // Add railing posts
                            const postCount = 8;
                            for (let j = 0; j < postCount; j++) {
                                const xPos = -terraceWidth / 2 + j * (terraceWidth / (postCount - 1));
                                
                                const post = new THREE.Mesh(railingGeometry, railingMaterial);
                                post.position.set(
                                    xPos,
                                    currentHeight - terraceHeight / 2 + railingHeight / 2,
                                    -terraceDepth / 2 + planterDepth + 0.05
                                );
                                group.add(post);
                            }
                        }
                    }
                }
                
                // Add top architectural feature for higher quality
                if (qualitySettings.quality !== 'low') {
                    const topFeatureGeometry = getBuildingGeometry('cylinder', {
                        radiusTop: 0,
                        radiusBottom: 5,
                        height: 8,
                        radialSegments: 6
                    }, detailLevel);
                    
                    const topFeatureMaterial = createMaterial('physical', {
                        color: 0xDDDDDD,
                        metalness: 0.8,
                        roughness: 0.2,
                        clearcoat: 0.5,
                        clearcoatRoughness: 0.2
                    }, 'terrace-top');
                    
                    const topFeature = new THREE.Mesh(topFeatureGeometry, topFeatureMaterial);
                    topFeature.position.y = currentHeight + 4;
                    topFeature.castShadow = qualitySettings.shadowsEnabled;
                    group.add(topFeature);
                    
                    // Add solar array on south side
                    const panelGeometry = getBuildingGeometry('box', {
                        width: baseWidth * 0.4,
                        height: 0.2,
                        depth: baseDepth * 0.6
                    }, detailLevel);
                    
                    const panelMaterial = createMaterial('standard', {
                        color: 0x2244AA,
                        metalness: 0.8,
                        roughness: 0.2
                    }, 'terrace-solar');
                    
                    const solarPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                    solarPanel.position.set(
                        0,
                        baseHeight * 0.4,
                        baseDepth * 0.7
                    );
                    solarPanel.rotation.x = Math.PI / 6; // Tilt for optimal sun
                    solarPanel.castShadow = qualitySettings.shadowsEnabled;
                    group.add(solarPanel);
                    
                    // Add glass entrance at ground level
                    const entranceGeometry = getBuildingGeometry('box', {
                        width: baseWidth * 0.3,
                        height: 5,
                        depth: 8
                    }, detailLevel);
                    
                    const entranceMaterial = createMaterial('physical', {
                        color: 0xEEEEFF,
                        metalness: 0.5,
                        roughness: 0.1,
                        transmission: 0.6,
                        thickness: 0.3,
                        envMapIntensity: 1.3,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1
                    }, 'terrace-entrance');
                    
                    const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
                    entrance.position.set(0, 2.5, baseDepth / 2 + 4);
                    entrance.castShadow = qualitySettings.shadowsEnabled;
                    group.add(entrance);
                }
                
                return group;
            }
            
            function createContemporaryTower(color, height) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Tower parameters
                const baseRadius = 8;
                const topRadius = 6;
                const segments = qualitySettings.quality === 'low' ? 8 : 
                                qualitySettings.quality === 'medium' ? 16 : 24;
                
                // Create tower core
                const coreGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: topRadius,
                    radiusBottom: baseRadius,
                    height: height * 0.9,
                    radialSegments: segments
                });
                
                // Create more sophisticated material with subtle texture blend
                const coreMaterial = createMaterial('physical', {
                    color: 0xCCCCCC,
                    metalness: 0.4,
                    roughness: 0.6,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.5
                }, 'tower-core');
                
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = height * 0.45;
                core.castShadow = qualitySettings.shadowsEnabled;
                core.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(core);
                
                // Add window strips
                if (qualitySettings.quality !== 'low') {
                    const stripCount = Math.max(8, Math.floor(segments * 0.75));
                    
                    for (let i = 0; i < stripCount; i++) {
                        const angle = (i / stripCount) * Math.PI * 2;
                        
                        // Create vertical window strip
                        const stripGeometry = getBuildingGeometry('box', {
                            width: 1.2,
                            height: height * 0.85,
                            depth: 0.1
                        }, detailLevel);
                        
                        // Create glass material with blue tint
                        const stripMaterial = createMaterial('physical', {
                            color: new THREE.Color(0.7, 0.8, 0.95),
                            metalness: 0.9,
                            roughness: 0.1,
                            transmission: 0.2,
                            thickness: 0.2,
                            envMapIntensity: 1.2,
                            clearcoat: 0.5,
                            clearcoatRoughness: 0.1
                        }, 'tower-window-strip');
                        
                        const strip = new THREE.Mesh(stripGeometry, stripMaterial);
                        
                        // Position strip on tower surface
                        const midRadius = (baseRadius + topRadius) / 2;
                        strip.position.set(
                            Math.sin(angle) * (midRadius + 0.05),
                            height * 0.45,
                            Math.cos(angle) * (midRadius + 0.05)
                        );
                        
                        // Rotate to align with tower
                        strip.rotation.y = angle + Math.PI / 2;
                        
                        strip.castShadow = qualitySettings.shadowsEnabled;
                        group.add(strip);
                    }
                    
                    // Add horizontal bands for architectural interest
                    const bandCount = Math.floor(height / 15);
                    
                    for (let i = 0; i < bandCount; i++) {
                        const bandY = height * 0.15 + i * (height * 0.7 / bandCount);
                        const bandRadius = baseRadius - (baseRadius - topRadius) * (bandY / height);
                        
                        const bandGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: bandRadius + 0.2,
                            radiusBottom: bandRadius + 0.2,
                            height: 0.5,
                            radialSegments: segments
                        }, detailLevel);
                        
                        const bandMaterial = createMaterial('standard', {
                            color: new THREE.Color(color).lerp(new THREE.Color(0xFFFFFF), 0.7),
                            metalness: 0.7,
                            roughness: 0.3
                        }, `tower-band-${i}`);
                        
                        const band = new THREE.Mesh(bandGeometry, bandMaterial);
                        band.position.y = bandY;
                        band.castShadow = qualitySettings.shadowsEnabled;
                        group.add(band);
                    }
                }
                
                // Add top cap
                const capGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: topRadius - 2,
                    radiusBottom: topRadius,
                    height: height * 0.1,
                    radialSegments: segments
                });
                
                const capMaterial = createMaterial('physical', {
                    color: new THREE.Color(color),
                    metalness: 0.6,
                    roughness: 0.4,
                    clearcoat: 0.5,
                    clearcoatRoughness: 0.3
                }, `tower-cap-${color}`);
                
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = height * 0.95;
                cap.castShadow = qualitySettings.shadowsEnabled;
                group.add(cap);
                
                // Add base features
                const baseGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: baseRadius,
                    radiusBottom: baseRadius + 2,
                    height: height * 0.05,
                    radialSegments: segments
                });
                
                const base = new THREE.Mesh(baseGeometry, capMaterial);
                base.position.y = height * 0.025;
                base.castShadow = qualitySettings.shadowsEnabled;
                base.receiveShadow = qualitySettings.shadowsEnabled;
                group.add(base);
                
                // Add realistic details for higher quality settings
                if (qualitySettings.quality !== 'low') {
                    // Add communication antennas on top
                    const antennaCount = qualitySettings.quality === 'high' ? 3 : 2;
                    
                    for (let i = 0; i < antennaCount; i++) {
                        const antennaHeight = 5 + i * 3;
                        const angle = (i / antennaCount) * Math.PI * 2;
                        const radius = topRadius * 0.5;
                        
                        const antennaGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: 0.05,
                            radiusBottom: 0.15,
                            height: antennaHeight,
                            radialSegments: 6
                        }, detailLevel);
                        
                        const antennaMaterial = createMaterial('standard', {
                            color: 0x888888,
                            metalness: 0.8,
                            roughness: 0.2
                        }, 'tower-antenna');
                        
                        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                        antenna.position.set(
                            Math.sin(angle) * radius,
                            height + antennaHeight / 2,
                            Math.cos(angle) * radius
                        );
                        antenna.castShadow = qualitySettings.shadowsEnabled;
                        group.add(antenna);
                        
                        // Add blinking light at top - very subtle for daylight
                        if (qualitySettings.effectsLevel !== 'minimal') {
                            const lightGeometry = getBuildingGeometry('sphere', {
                                radius: 0.2,
                                widthSegments: 8,
                                heightSegments: 8
                            }, detailLevel);
                            
                            const lightMaterial = createMaterial('standard', {
                                color: 0xFF0000,
                                emissive: 0xFF0000,
                                emissiveIntensity: 0.2, // Very subtle glow in daylight
                                transparent: true,
                                opacity: 0.9
                            }, 'tower-light');
                            
                            const light = new THREE.Mesh(lightGeometry, lightMaterial);
                            light.position.y = antennaHeight + 0.2;
                            light.castShadow = false;
                            
                            // Store for blinking animation
                            light.userData = { 
                                isBlinkingLight: true, 
                                blinkSpeed: 0.5 + Math.random() * 0.5
                            };
                            
                            antenna.add(light);
                        }
                    }
                    
                    // Add entrance pavilion
                    const entranceGeometry = getBuildingGeometry('box', {
                        width: 10,
                        height: 6,
                        depth: 6
                    }, detailLevel);
                    
                    const entranceMaterial = createMaterial('physical', {
                        color: 0xEEEEEE,
                        metalness: 0.3,
                        roughness: 0.2,
                        transmission: 0.1,
                        thickness: 0.4,
                        envMapIntensity: 1.0,
                        clearcoat: 0.6
                    }, 'tower-entrance');
                    
                    const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
                    entrance.position.set(0, 3, baseRadius + 3);
                    entrance.castShadow = qualitySettings.shadowsEnabled;
                    entrance.receiveShadow = qualitySettings.shadowsEnabled;
                    group.add(entrance);
                    
                    // Add canopy over entrance
                    const canopyGeometry = getBuildingGeometry('box', {
                        width: 12,
                        height: 0.5,
                        depth: 4
                    }, detailLevel);
                    
                    const canopy = new THREE.Mesh(canopyGeometry, capMaterial);
                    canopy.position.set(0, 6.5, baseRadius + 5);
                    canopy.castShadow = qualitySettings.shadowsEnabled;
                    group.add(canopy);
                    
                    // Add support columns for canopy
                    [-5, 5].forEach(xPos => {
                        const columnGeometry = getBuildingGeometry('cylinder', {
                            radiusTop: 0.25,
                            radiusBottom: 0.25,
                            height: 3,
                            radialSegments: 8
                        }, detailLevel);
                        
                        const column = new THREE.Mesh(columnGeometry, entranceMaterial);
                        column.position.set(xPos, 5, baseRadius + 5);
                        column.castShadow = qualitySettings.shadowsEnabled;
                        group.add(column);
                    });
                }
                
                return group;
            }
            
            function createSubtleHologram(title, color) {
                const detailLevel = qualitySettings.geometryDetail;
                const group = new THREE.Group();
                
                // Base emitter with subtle design
                const emitterGeometry = getBuildingGeometry('cylinder', {
                    radiusTop: 1.5, 
                    radiusBottom: 2, 
                    height: 0.5,
                    radialSegments: qualitySettings.quality === 'low' ? 8 : 16
                });
                
                // Use a subtler material for the emitter base
                const emitterMaterial = createMaterial('standard', {
                    color: 0x444444,
                    emissive: color,
                    emissiveIntensity: 0.05, // Very subtle glow for daylight
                    metalness: 0.8,
                    roughness: 0.2
                }, `subtle-emitter-${color}`);
                
                const emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
                emitter.position.y = -0.25;
                emitter.castShadow = qualitySettings.shadowsEnabled;
                group.add(emitter);
                
                // Holographic text with muted effect for daylight
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 1024;
                textCanvas.height = 256;
                const ctx = textCanvas.getContext('2d');
                
                // Draw transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, 1024, 256);
                
                // Draw text with darker shadow for better daylight visibility
                ctx.font = 'bold 100px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Shadow for daylight visibility
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                // Calculate a more visible color for daylight
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;
                
                // Darken the color for better visibility
                const darkerColor = `rgb(${Math.floor(r * 0.7)}, ${Math.floor(g * 0.7)}, ${Math.floor(b * 0.7)})`;
                
                // Text color (darker for daylight visibility)
                ctx.fillStyle = darkerColor;
                ctx.fillText(title.toUpperCase(), 512, 128);
                
                // Create texture
                const textTexture = new THREE.CanvasTexture(textCanvas);
                
                // Use shader for high quality, simple material for low
                let textMaterial;
                
                if (qualitySettings.quality === 'low') {
                    textMaterial = createMaterial('basic', {
                        map: textTexture,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                } else {
                    textMaterial = createShaderMaterial({
                        map: { value: textTexture },
                        time: { value: 0 },
                        color: { value: new THREE.Color(color) }
                    },
                    // Vertex shader
                    `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    // Fragment shader (optimized for daylight with subtle effects)
                    `
                        uniform sampler2D map;
                        uniform float time;
                        uniform vec3 color;
                        varying vec2 vUv;
                        
                        void main() {
                            vec4 texColor = texture2D(map, vUv);
                            
                            // Add subtle scan line effect
                            float scanline = step(0.99, fract(vUv.y * 100.0 - time * 1.5)) * 0.1;
                            
                            // Add very subtle glitch effect
                            float glitchIntensity = step(0.98, sin(time * 10.0 + vUv.y * 50.0)) * 0.1;
                            float glitchLine = step(0.5, fract(vUv.y * 100.0));
                            float glitch = glitchIntensity * glitchLine;
                            
                            // Minimal distortion
                            vec2 distortion = vec2(
                                sin(vUv.y * 20.0 + time) * 0.002,
                                0.0
                            ) * glitchIntensity;
                            
                            vec4 distortedColor = texture2D(map, vUv + distortion);
                            
                            // Combine effects - muted colors for daylight
                            vec3 finalColor = mix(color * 0.8, color, scanline + glitch);
                            
                            float alpha = distortedColor.a * (0.9 + 0.1 * sin(time * 3.0));
                            alpha = mix(alpha, alpha * 1.2, scanline);
                            
                            gl_FragColor = vec4(finalColor, alpha * texColor.a * 0.85);
                        }
                    `,
                    {
                        transparent: true,
                        blending: THREE.NormalBlending,
                        side: THREE.DoubleSide
                    });
                }
                
                const textGeometry = getBuildingGeometry('plane', {
                    width: 10, 
                    height: 2.5
                });
                
                const text = new THREE.Mesh(textGeometry, textMaterial);
                text.position.y = 3.5;
                text.rotation.x = -Math.PI / 10;
                group.add(text);
                
                // Store for shader updates if using shader material
                if (qualitySettings.quality !== 'low') {
                    neonSigns.push(text);
                }
                
                // Add subtle holographic beam
                if (qualitySettings.effectsLevel !== 'minimal') {
                    const beamSegments = qualitySettings.quality === 'high' ? 16 : 8;
                    
                    const beamGeometry = getBuildingGeometry('cylinder', {
                        radiusTop: 0.2, 
                        radiusBottom: 1.5, 
                        height: 7,
                        radialSegments: beamSegments,
                        heightSegments: 1,
                        openEnded: true
                    });
                    
                    const beamMaterial = createShaderMaterial({
                        time: { value: 0 },
                        color: { value: new THREE.Color(color) }
                    },
                    // Vertex shader
                    `
                        uniform float time;
                        varying vec2 vUv;
                        
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    // Fragment shader (much more subtle for daylight)
                    `
                        uniform float time;
                        uniform vec3 color;
                        varying vec2 vUv;
                        
                        void main() {
                            // Create flowing beam effect
                            float flow = fract(vUv.y * 5.0 - time * 1.5);
                            flow = pow(flow, 3.0) * (1.0 - flow) * 2.0;
                            
                            // Add some noise
                            float noise = 0.95 + 0.05 * sin(vUv.x * 30.0 + time * 5.0);
                            
                            // Calculate alpha - reduced for daylight
                            float alpha = (1.0 - vUv.y) * 0.2 * noise;
                            alpha = mix(alpha, alpha * 1.5, flow);
                            
                            gl_FragColor = vec4(color * 0.9, alpha * 0.6);
                        }
                    `,
                    {
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    beam.position.y = 3.5;
                    group.add(beam);
                    
                    // Store for shader updates
                    neonSigns.push(beam);
                }
                
                return group;
            }
            
            function createSubtleEnergyField(color) {
                // Create a much more subtle energy field for daylight
                const detailLevel = qualitySettings.geometryDetail;
                
                const geometry = getBuildingGeometry('sphere', {
                    radius: 1,
                    widthSegments: qualitySettings.quality === 'high' ? 32 : 16,
                    heightSegments: qualitySettings.quality === 'high' ? 16 : 8
                });
                
                // Create a muted color by blending with white
                const mutedColor = new THREE.Color(color).lerp(new THREE.Color(0xFFFFFF), 0.3);
                
                const material = createShaderMaterial({
                    time: { value: 0 },
                    color: { value: mutedColor }
                },
                // Vertex shader
                `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment shader (significantly reduced brightness and effects)
                `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0))), 2.0);
                        fresnel = mix(0.05, 0.3, fresnel); // Reduced effect
                        
                        float pulse = 0.8 + 0.2 * sin(time * 2.0); // Gentler pulse
                        
                        // Create simplified energy pattern with reduced intensity
                        float grid = max(
                            step(0.99, sin(vUv.y * 15.0 + time)),
                            step(0.99, sin(vUv.x * 15.0 + time))
                        );
                        
                        // More subtle colors
                        vec3 finalColor = color * fresnel * pulse * 0.8;
                        finalColor = mix(finalColor, vec3(color) * 1.2, grid * 0.4);
                        
                        float alpha = 0.05 * fresnel * pulse; // Very low base opacity
                        alpha = mix(alpha, 0.2, grid * 0.5); // Still subtle on grid lines
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                {
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                
                // Store for shader updates
                neonSigns.push(sphere);
                
                return sphere;
            }
        }

        // Start the experience
        init();
    </script>
</body>
</html>
